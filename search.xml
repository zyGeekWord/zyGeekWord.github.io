<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单例模式</title>
    <url>/2021/03/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Java的设计模式一共有23中，今天我们说单例模式，单例模式是一种最常见的设计模式，在springmvc中bean的注入使用的就是单例模式。</p>
<p>单例模式，只能存在一个实例，并且自己创建自己的对象，这个类提供了一个访问这个对象的唯一方式，可直接访问，不需要通过new来创建一个新的对象，单例模式一共有五种创建方式，下面分别查看这几种方式。</p>
<span id="more"></span>

<p><strong>单例模式的优点：</strong></p>
<ol>
<li>内存中只有一个对象，节省内存空间。</li>
<li>避免频繁的创建销毁对象，可以提高性能。</li>
<li>避免对共享资源的多重占用，简化访问。</li>
<li>为整个系统提供一个全局访问点。</li>
</ol>
<p><strong>单例模式的缺点：</strong></p>
<ol>
<li>不适用于变化频繁的对象。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现的链接池溢出。</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象时垃圾而被回收，这可能会导致对象状态的丢失。</li>
</ol>
<h4 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LanHan&#123;</span><br><span class="line">    private static LanHan lan;</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private LanHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;判断，当没有创建过对象的时候才会创建新对象</span><br><span class="line">    public static LanHan getLan()&#123;</span><br><span class="line">        if(lan&#x3D;&#x3D;null)&#123;</span><br><span class="line">            lan &#x3D; new LanHan;</span><br><span class="line">        &#125;</span><br><span class="line">        return lan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式，只有在使用的时候才会创建</p>
<p><strong>优点：</strong>节省内存空间，只有在真正调用的时候才会实例化对象并调用。</p>
<p><strong>缺点：</strong>只能在单线程情况下使用，在多线程情况下，一个线程进行if else 判断的时候还没有进行运算完成，接下来的线城也进入判断，这样便会创建了多个实例，违背了单例模式的设计意义，并且，严格意义上来说，懒汉式并不属于单例模式</p>
<h4 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EHan&#123;</span><br><span class="line">    &#x2F;&#x2F;创建自己的私有静态对象</span><br><span class="line">    private static EHan eh &#x3D; new EHan();</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;返回自己实例的静态公有方法</span><br><span class="line">    public EHan getEH()&#123;</span><br><span class="line">        return en;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式，在初始化时已经创建好，不管是否调用</p>
<p><strong>优点：</strong>在整个生命周期只会被加载一次，只会创建一个实例，这种写法很简单，避免了线程同步的问题</p>
<p><strong>缺点：</strong>在类装载的时候就完成实例化，如果始终没有调用的话，会浪费内存</p>
<h4 id="3-双重加锁机制"><a href="#3-双重加锁机制" class="headerlink" title="3.双重加锁机制"></a>3.双重加锁机制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class twoLwtion&#123;</span><br><span class="line">    private static twoLwtion instance;</span><br><span class="line">     private static readonly object syncRoot &#x3D; new object();</span><br><span class="line">        private twoLwtion() &#123; &#125;</span><br><span class="line">        public static twoLwtion GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;先判断是否存在，不存在再加锁处理</span><br><span class="line">            if (instance &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;在同一个时刻加了锁的那部分程序只有一个线程可以进入</span><br><span class="line">                lock (syncRoot)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong>lock锁</p>
<p>Double-Check概念，进行了两次if检测，这样可以保证线程安全，这样实例化代码只用执行一次，后面再次访问时，判断singleton==null直接返回实例化对象</p>
<p>使用双重检测同步延迟加载去创建单例模式是一种非常优秀的做法，不但保持了单例，还切实提高了程序运行效率</p>
<p><strong>优点：</strong>线城安全，延迟加载，效率高</p>
<h4 id="4-静态初始化"><a href="#4-静态初始化" class="headerlink" title="4.静态初始化"></a>4.静态初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class staticleton &#123; </span><br><span class="line">    private staticleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      public static staticleton getInstance()&#123;  </span><br><span class="line">        return Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class Inner &#123;  </span><br><span class="line">        private static final Singleton instance &#x3D; new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p>
<p><strong>优点：</strong>利用了classloader机制来保证初始化instance时只有一个线程，线程安全且没有性能损耗</p>
<h4 id="5-枚举单例模式"><a href="#5-枚举单例模式" class="headerlink" title="5.枚举单例模式"></a>5.枚举单例模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;doSomething 该实例支持的行为</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;可以省略此方法，通过Singleton.INSTANCE进行操作</span><br><span class="line">    public static Singleton get Instance() &#123;</span><br><span class="line">        return Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类单例模式是日常开发中比较少用到的单例模式，原因是可读性较差</p>
<p><strong>优点：</strong>不仅可以解决多线程同步问题，还能有效防止反序列化重新创建新的对象</p>
<p><strong>缺点：</strong> jdk1.5中加入了enum，不常用，并且可读性差</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>目前来说，比较推荐的是静态内部类单例模式</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2021/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>整个操作看成为一个整体，要么成功，要么失败，有一个回滚机制</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>这里涉及到了数据库锁<br>排他锁<br>X锁，写锁<br>共享锁<br>S锁，读锁<br>可能会有多个线程同时访问同一条数据，这样数据库会出现一条数据多方调用，这么做会产生数据的更新丢失，<br>为了压制数据更新丢失，数据库标准提出了四类隔离级别</p>
<span id="more"></span>

<h5 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h5><p>未提交读是最低的隔离级别，他允许一个事务读取另一个事务未提交的数据，未提交读是一种非常危险的隔离级别<br><strong>优点</strong><br>并发能力高，适用对数据一致性没有高要求的并发场景<br><strong>缺点</strong><br>会产生脏读<br>脏读的场景为在一条事务未提交时，令一条事务访问了当前事务的数据，但是当前事务数据回滚了，这时，读取到的事务就成为脏读</p>
<h5 id="读写提交"><a href="#读写提交" class="headerlink" title="读写提交"></a>读写提交</h5><p>在事务A进行的时候，事务B不会读取到事务A的任何数据<br><strong>优点</strong><br>读取事务不需要担心其他事务回滚而产生的脏读数据<br><strong>缺点</strong></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>当数据库数据只剩一个的情况下，事务A先扣除库存，这时事务B也进行扣除库存，因为无法读取事务A的操作，所以事务B判断可以扣除库存，这时事务A提交了数据,之后事务B提交数据就会提交失败，因为此时库存为0无法扣除<br>一般发生在delete和update中</p>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>在一个事务进行操作的时候，其他事务不允许读取当前数据库，要等待当前事务提交后才能进行读取，但是在一个事务中多次查询的结果是一致的<br><strong>优点</strong><br>可以完美的避开不可重复读的问题<br><strong>缺点</strong><br>幻读<br>发生在insert中<br>当事务A中有两条select语句，当执行完第一条select语句口，事务B对数据库进行了操作，添加了一条数据，这时事务A第二条select查看就会发现多了一条之前没有查到的数据<br>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。<br>解决方案，innodb数据库引擎已经解决当前问题<br>Innodb引入间隙锁</p>
<h5 id="串行话"><a href="#串行话" class="headerlink" title="串行话"></a>串行话</h5><p>这个是数据库的最高隔离级别，当一个事务执行时，其他事务都要排队，按顺序一个一个的进行<br>缺点<br>会产生数据的冗余</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>当整个事务执行完毕后，所有数据都会被固化到磁盘中，供长期的访问</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务在完成时，必须使所有事务都保持一致</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>装箱拆箱</title>
    <url>/2021/03/10/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="装箱-java中将这个机制设置为自动"><a href="#装箱-java中将这个机制设置为自动" class="headerlink" title="装箱(java中将这个机制设置为自动)"></a>装箱(java中将这个机制设置为自动)</h2><ul>
<li>装箱的概念为将基本数据类型转换为包装类型</li>
<li>构造函数：可用于将基本类型转换为包装器类型</li>
<li>valueOf()：可用于将基本类型转换为包装器类型</li>
<li>自动装箱<ul>
<li><p>int x= 1; Integer y = x;</p>
</li>
<li><p>public void demo(Integer a){} int x = 1; demo(x);</p>
<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="拆箱-java中将这个机制设置为自动"><a href="#拆箱-java中将这个机制设置为自动" class="headerlink" title="拆箱(java中将这个机制设置为自动)"></a>拆箱(java中将这个机制设置为自动)</h2><ul>
<li>拆箱的概念为将包装器类型转换成基本数据类型</li>
<li>byteValue()、shortValue()等xxxValue()方法：可用于将包装器类型转换为基本数据类型</li>
<li>parseInt()等parseXxx()方法：可用于将String对象转换为基本数据类型</li>
<li>toString()方法：由Object对象继承而来，用于将包装器类型转换为String类型</li>
<li>自动拆箱<ul>
<li>Integer x = new Integer(1); int y = x ;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/03/10/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存（缓存雪崩，缓存击穿，缓存穿透）"><a href="#缓存（缓存雪崩，缓存击穿，缓存穿透）" class="headerlink" title="缓存（缓存雪崩，缓存击穿，缓存穿透）"></a>缓存（缓存雪崩，缓存击穿，缓存穿透）</h1><p><strong>首先</strong>，什么是缓存，在计算机中，数据的运行方式是 CPU&gt;内存&gt;储存，所以内存是直接与cpu交流的，最接近CPU的，所以内存的效率是很高的，但是，内存是RAM，也就是说，当机器停机或断电情况下，内存会全部消失。</p>
<span id="more"></span>

<p>在日常开发中我们使用的缓存一般是指redis缓存数据库，redis的细节在此不做讲解，后续会出一篇redis的文章，在此篇文章中主要介绍缓存雪崩，缓存击穿，缓存穿透这三个问题。</p>
<p> 我们为什么要在项目中添加缓存，直接用数据库查询不好么？一条sql直接搞定，这是我在刚接触到缓存的时候想的问题，为什么呢，首先，缓存有两个主要的用途：<strong>高性能，高并发</strong>，现在是一个高并发的时代，会有很多人同时操作我们的项目，这时，数据库能承受多少的访问量呢？一条sql的select查询需要多久呢？每次我们操作都需要去数据库查询一遍相同的数据是不是重复操作呢？这些重复操作会浪费掉我们多少的性能呢？当有人恶意访问把我们的数据库查崩了会怎么样呢？等等好多的问题，都指向了缓存。</p>
<p>首先，redis数据库是非关系型数据库，一个key一个value，当我们在项目中加入缓存后，第一个人查询完，第二个人直接去缓存中拿这个数据，不需要再走一遍sql，最简单的例子，一条sql查询某个数据需要300ms，而你将这些数据放入到redis中，下次通过这个key进行查询的时候只需要3ms就可以查询出来。在高并发的情况下，mysql天然支持不是很好，当然也不是非说不可以，假如在我们的项目中，某个时间段，一秒钟有一万个请求，那么单个mysql的项目绝对会垮掉，这时候只要我们加上缓存，把大量的数据都放进缓存中，单个redis就可以轻松支撑每秒几万到几十万的数据，他的承载并发量是mysql的几十倍。</p>
<p>接下来步入正题，使用缓存后我们会遇到的第一个问题，缓存雪崩，缓存击穿，缓存穿透，这三种最常见的地方就是在电商项目中。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><strong>场景</strong><br>同一时间下有大量的数据同时失效，这时会对数据库产生庞大的压力<br>双十一十二点，大量用户访问商品，加入商品有效时间为一小时，一点后，所有缓存全部到期，这时就会触发缓存雪崩</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>高可用：</strong> redis主从复制和redis集群，redis 集群有哨兵和Cluster等，此处不做详细讲解</p>
<p><strong>限流降级：</strong> 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>随机过期时间：</strong> 将缓存的有效时间设置为随机数，每个缓存的失效时间都不相同，这样就可以有效的解决缓存雪崩</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>场景</strong><br>在大数据量的访问时，缓存失效了，这时会有大量请求直接击穿数据库，这就是缓存击穿<br>在淘宝中，一个商品卖成了热卖商品，在热卖的过程中，缓存失效了，这时一瞬间就会触发缓存雪崩问题</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>添加互斥锁</p>
<p>将热卖商品的缓存过期时间设置为永不过期</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>场景</strong><br>当有人知道当前请求的路径后，多次请求并不存在的数据，这样就会使请求直接穿透到数据库上，导致数据库压力过大<br>一个人恶意请求数据，疯狂发送不存在的数据，这时会产生缓存穿透</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>创建黑名单，将数据库不存在的数据存入到缓存黑名单中，每次访问，如果传参在黑名单中，则将黑名单中信息直接返回给请求者，这样可以避免数据走数据库</p>
<p>本人也在学习阶段，如有哪里写的有问题欢迎指点，不喜勿喷</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>redis为什么要配置连接池</title>
    <url>/2021/03/23/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>​         redis以高性能著称，但是我们在日常使用中，需要将项目和redis进行连接操作，并且也会有redis和项目不在一个服务器中的情况，当我们调用redis时，假如耗时30ms，那么redis的响应和处理时间有可能才占1ms，剩下的29ms全都是链接所消耗的时间，所以，我们配置连接池，连接池中会一直保持几个链接，当项目需要时直接调用，节省连接时间，提升性能</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池之Druid--配置篇</title>
    <url>/2021/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B9%8BDruid/</url>
    <content><![CDATA[<p>日常开发中数据库是我们都要使用的，使用数据库也就意味着必须建立项目和数据之间的联系，所以我们需要使用数据库连接池，目前我选择使用druid连接池，该连接池是阿里开源的，功能非常强大，最大的特点是可以监控sql和可视化界面，目前各种数据库连接池的特点如下图所示</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210330202641268.png" alt="image-20210330202641268"></p>
<p><strong>步入正题</strong></p>
<span id="more"></span>

<p>druid有两种配置方式，阿里开源框架中为了springboot提供了封装好的引用包和druid原生的包，分别为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此依赖为druid原生的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 此依赖为springboot--druid的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-引用springboot-druid的配置"><a href="#1-引用springboot-druid的配置" class="headerlink" title="1. 引用springboot-druid的配置"></a>1. 引用springboot-druid的配置</h2><p>引用springboot-druid包后，当前包中已经为我们配置好了配置文件的映射方法，所以我们只需要在配置文件中添加配置就好，配置文件如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#以下为druid增加的配置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化时建立物理连接的个数</span><br><span class="line">spring.datasource.druid.initial-size=50</span><br><span class="line"># 最小连接池数量</span><br><span class="line">spring.datasource.druid.min-idle=50</span><br><span class="line"># 最大连接池数量</span><br><span class="line">spring.datasource.druid.max-active=10</span><br><span class="line"># 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁</span><br><span class="line">spring.datasource.druid.max-wait=60000</span><br><span class="line"># 有两个含义：</span><br><span class="line">#1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。</span><br><span class="line">#2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</span><br><span class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</span><br><span class="line"># 连接保持空闲而不被驱逐的最小时间</span><br><span class="line">spring.datasource.druid.min-evictable-idle-time-millis=30000</span><br><span class="line"># 用来检测连接是否有效的SQL,如果未null,testOnBorrow,testOnReturn,testWhileIdle不会起作用</span><br><span class="line">spring.datasource.druid.validation-query=SELECT 1</span><br><span class="line"># 检测链接是否有效的超时时间,单位秒;底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</span><br><span class="line">spring.datasource.druid.validation-query-timeout=10</span><br><span class="line"># 建议配置为true,不影响性能,并且保证安全性.申请连接的时候检测,如果空闲时间大于timeBetweenEvictionRunsMills,执行validationQuery检测连接是否有效.</span><br><span class="line">spring.datasource.druid.test-while-idle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-borrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-return=false</span><br><span class="line"># 是否缓存preparedStatement,即PSCache,PSCache对支持游标的数据库性能提升巨大,如oracle,mysql下建议关闭</span><br><span class="line">spring.datasource.druid.pool-prepared-statements=false</span><br><span class="line"># 要启用PSCache,必须配置大于0,当大于0时,上面配置自动修改为true;Druid中不会存在Oracle下PSCache占用内存过多的问题,可以把数值配置大一些,如100</span><br><span class="line">spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20</span><br><span class="line">spring.datasource.druid.filter.stat.enabled=true</span><br><span class="line">spring.datasource.druid.filter.stat.merge-sql=true</span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=5000</span><br><span class="line">#WebStatFilter监控配置</span><br><span class="line"># 这个教程很保姆,参考https://blog.csdn.net/qq_45173404/article/details/109075810</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=100</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line">#页面登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class="line">#页面登录用户密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br></pre></td></tr></table></figure>

<h2 id="2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"><a href="#2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式" class="headerlink" title="2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"></a>2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式</h2><p> 配置类如下所述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  主要实现WEB监控的配置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在要进行druid监控的配置处理操作</span></span><br><span class="line">        ServletRegistrationBean servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">                <span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 白名单,多个用逗号分割， 如果allow没有配置或者为空，则允许所有访问</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;127.0.0.1,172.29.32.54&quot;</span>);</span><br><span class="line">        <span class="comment">// 黑名单,多个用逗号分割 (共同存在时，deny优先于allow)</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;deny&quot;</span>, <span class="string">&quot;192.168.1.110&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理用户名</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理密码</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;eju1314&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否可以重置数据源，禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean() ;</span><br><span class="line">    filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">    <span class="comment">//所有请求进行监控处理</span></span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>); </span><br><span class="line">    <span class="comment">//添加不需要忽略的格式信息</span></span><br><span class="line">    filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.css,/druid/*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完配置类后，我们的配置文件中配置如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.name=dev</span><br><span class="line"># 基本属性</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line"># 可以不配置，根据url自动识别，建议配置</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#=================================以下为druid增加的配置==========================</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化连接池个数</span><br><span class="line">spring.datasource.initialSize=5</span><br><span class="line"># 最小连接池个数——》已经不再使用，配置了也没效果</span><br><span class="line">spring.datasource.minIdle=2</span><br><span class="line"> # 最大连接池个数</span><br><span class="line">spring.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间，单位毫秒，缺省启用公平锁，并发效率会有所下降</span><br><span class="line">spring.datasource.maxWait=60000</span><br><span class="line"> # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">spring.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">spring.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line">spring.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line"># 建议配置为true，不影响性能，并且保证安全性。</span><br><span class="line"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span><br><span class="line">spring.datasource.testWhileIdle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnBorrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">spring.datasource.poolPreparedStatements=true</span><br><span class="line">spring.datasource.maxPoolPreparedStatementPerConnectionSize=20</span><br><span class="line"># 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有： </span><br><span class="line"># 监控统计用的filter:stat</span><br><span class="line"># 日志用的filter:log4j</span><br><span class="line"># 防御sql注入的filter:wall</span><br><span class="line">spring.datasource.filters=stat,wall,log4j</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">spring.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven如何使项目打包时排除指定的依赖</title>
    <url>/2021/03/30/maven%E5%A6%82%E4%BD%95%E4%BD%BF%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%97%B6%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>打包时，需要将项目中的一些依赖排除出去，查询后使用代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.58.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，使用了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此命令行可以使下项目打包时不将该依赖打包进去。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String字符串有没有上限</title>
    <url>/2021/04/01/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E6%B2%A1%E6%9C%89%E4%B8%8A%E9%99%90/</url>
    <content><![CDATA[<p>String字符串到底有没有上限呢？我们通过源码来分析。</p>
<p><strong>首先</strong>，我们需要知道String字符串实际是用什么存储的，在jdk1.6中，String是用byte数组存储的，在jdk1.8中，String是用char[]存储的。</p>
<p>数组，我们是需要可以设置大小的，数组设置大小有两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">12</span>]; <span class="comment">//数组长度为12</span></span><br><span class="line"><span class="keyword">char</span>[] ar = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//数组长度为5</span></span><br></pre></td></tr></table></figure>

<p>其中，数组长度的定义都为整数，至于为什么是整数类型，我们可以看一下length()这个方法，该方法的返回值是int类型，所以数组长度不可能超过int类型的上限，我们通过Integer的代码中可以看到：</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxValue &#x3D; Integer.MAX_VALUE;</span><br><span class="line">&#x2F;&#x2F;查看MAX_VALUE的源码</span><br></pre></td></tr></table></figure>

<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210401230126446.png" alt="image-20210401230126446"></p>
<p>注释中写道，int的最大值为2^31-1也就是2147483647 = 4GB。</p>
<p>所以String的最大长度应该是2147483647，但是，我们测试一下，创建一个十万个字节长的字符串，使用String a = “”;方式来创建，编译后，jvm报错，提示原因是，字符串长度过长，为什么会这样呢？由此引出了下面的问题，String创建的两种方式。</p>
<p>String字符串有两种创建方式，分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;adasdsdasd&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;asdasda&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这两种创建方式存储的地方是不一样的，字符串a创建后，会存储在常量池中，而字符串s则被存储在堆内存中。</p>
<p><strong>存储在常量池：</strong></p>
<p>常量池中数组的有效长度为0-65535，但是虚拟机还需要一个字节的指令作为结束，所以真正的有效范围为0~65534（至于为什么是这个范围，本文不做解释，后续文章会有所解释），也就是说，通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>创建的字符串，因为是一个常量，所以会被存储在常量池中，存储在常量池的话，就需要被常量池的规则约束，上限为65534个字节的长度，如果拼接字符串的话则不需要遵守这个约束，因为拼接后是一个对象，存储在堆内存中。</p>
<p><strong>存储在堆内存：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;asdasda&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为a字符串是new出来的，所以是一个对象，所以它的值会被存储在堆内存中，在堆内存中的字符串则不需要遵守常量池的约束可以达到整型的最大值。</p>
<p><strong>结论</strong></p>
<p>当字符串在常量池中时，上限为65534。</p>
<p>当字符串为拼接，或者扶着的话范围为整形的最大值。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap(一)</title>
    <url>/2021/04/09/ConcurrentHashMap-%E4%B8%80/</url>
    <content><![CDATA[<p>当我们提到Map集合的时候，我们第一想法都是HashMap和HashTable，但是HashMap和HashTable都有自己的缺点。</p>
<p>首先HashMap它跟HashTable比，HashMap因为没有加锁，所以它的效率很高，但同时，它在多线程环境下，它无法保证数据同步，反之HashTable加了锁，但是同时也使它的效率降低，所以，在jdk1.5中加入了ConcurrentHashMap，但是ConcurrentHashMap发扬光大的还是在jdk1.7和1.8版本中，这两个版本的ConcurrentHashMap有着非常巨大的区别，本章我们先初步介绍这两个版本的ConcurrentHashMap。</p>
<h2 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h2>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群架构</title>
    <url>/2021/04/09/redis%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>a先说说是为什么引入的redis集群，在我开发的一个项目中，涉及到了缓存雪崩的问题，当时想到的解决方案是，写一个随机数，随机redis的失效时间，但是，在后续发现了一个问题。</p>
<p><strong>例如：</strong>在早上七点我redis随机了三个小时失效，早上八点我又随机了两个小时失效，这种情况下，在早上十点还是会引发雪崩的问题，并且我们无法保证redis宕机后会怎么办，所以引出了今天redis集群的思考，接下来我们先学习一下reids集群的三种模式。</p>
<span id="more"></span>

<h2 id="1-主从模式"><a href="#1-主从模式" class="headerlink" title="1.主从模式"></a>1.主从模式</h2><p>我们先说一下主从模式的模型，一台主redis，其他子redis全部链接主redis，如下图所示</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png?Expires=1617978251&OSSAccessKeyId=TMP.3KjuXqBNoxYUJsUN2DMecUGsMv17fXxuEez93MK7Y9YojdR3ot12T887moFvZ8kbEwAFArs7xYPBWtdP5koLG6znEkXSow&Signature=hTkuCfyguf0aBlOvY0e8CA5hIJU=" alt="文件无法预览。"></p>
<p><strong>器中主从模式有如下特点：</strong></p>
<ol>
<li><p>主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库</p>
</li>
<li><p>从数据库一般都是只读的，并且接收主数据库同步过来的数据</p>
</li>
<li><p>一个master可以拥有多个slave，但是一个slave只能对应一个master</p>
</li>
<li><p>slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来</p>
</li>
<li><p>master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务</p>
</li>
<li><p>master挂了以后，不会在slave节点中重新选一个master</p>
</li>
</ol>
<p>  <strong>工作机制</strong></p>
<p>  当slave启动后主动向master发送SYNC命令，master接收到SYNC命令后，在后台保存快照(RDB持久化)和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令(这里的redis持久化可看redis持久化那篇文章)。<br>  复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。<br>  当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制<br>  主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。</p>
<p>  <strong>优点:</strong>  只从master中进行写操作，读操作全都从slave中进行操作，减轻了服务器的压力</p>
<p>  <strong>缺点:</strong>  当master端坏掉后，则无法进行写操作</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>  如果多个slave同时断线需要重启的时候，因为只要slave启动，就会和master建立连接发送SYNC请求和主机全量同步，如果多个同时发送SYNC请求，可能导致master IO突增而发送宕机。</p>
<h2 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2.哨兵模式"></a>2.哨兵模式</h2><p>主从模式的弊端就是不具备高可用性，当master挂掉以后，redis无法对外提供写入操作，所以产生了哨兵模式。哨兵模式就是，监控redis集群的运行情况</p>
<p><strong>哨兵模式的特点：</strong></p>
<ul>
<li>sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义</li>
<li>当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master</li>
<li>当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据</li>
<li>sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群</li>
<li>多sentinel配置的时候，sentinel之间也会自动监控</li>
<li>当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心</li>
<li>一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis</li>
<li>sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了</li>
</ul>
<p><strong>哨兵模式工作机制：</strong></p>
<ul>
<li>每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 </li>
<li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 </li>
<li>如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态</li>
<li>当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 </li>
<li>在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 </li>
<li>当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 </li>
<li>若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；<br>若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除</li>
</ul>
<p>当我们在使用哨兵模式时，客户端不要直接链接redis，直接链接sentinel的ip和端口就可以，因为哨兵模式中，我们使用sentinel来提供具体可提供服务的redis，这样，当master节点挂掉后，sentinel就会感知并将新的master节点提供给我们，从而避免我们不知道应该连接哪个节点的问题。</p>
<p>(哨兵模式的配置问题不在本章中作为讲解)</p>
<h2 id="3-集群模式"><a href="#3-集群模式" class="headerlink" title="3.集群模式"></a>3.集群模式</h2><p>哨兵模式可以基本满足我们平时开发的需求，并具备高可用性，但是当数据量过大到一台服务器放不下的情况，主从模式和哨兵模式就无法满足需求了，这时有一个解决方案是将数据分片存储，将数据分别存储到多个redis实例中，集群模式是专门为了解决单机存储上限的问题，将redis的数据根据一定的规则分配到多台服务器中。</p>
<p>集群模式可以说是哨兵模式和主从模式的融合，通过集群模式可以实现主从那个和master重选功能，所以如果配置两个副本三个分片的话，就要配置六个redis服务。因为redis的数据是根据一定鬼册分配到集群的不同机器中，当数据量过大时，可以增加机器进行扩容，使用集群，是需要将redis配置文件中的’cluster-enable’配置打开即可，每个集群中至少需要三个主数据库才能正常运行，新增节点方便。</p>
<p><strong>集群模式特点:</strong></p>
<ul>
<li>多个redis节点网络互联，数据共享 </li>
<li>所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用 </li>
<li>不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上， 并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为 </li>
<li>支持在线增加、删除节点 </li>
<li>客户端可以连接任何一个主节点进行读写</li>
</ul>
<p>这里需要主义的一点是，如果redis版本较低，则需要安装ruby，人选一台机器安装ruby即可，redis5.0以上版本可以直接创建集群。</p>
<p>redis集群是去中心化的，每个节点都是平等的，链接哪个节点都是可以获取和设置数据。平等只得是master节点，因为slave节点根本不提供服务，只是作为对应master节点的一个备份</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是集群的介绍，但是集群能解决的只是数据的可用性，和稳定性，我们最开始的起点还是无法解决，在下面我们继续对以上的问题进行解决分析，我们解决了数据库宕机引发的问题，接下来我们还需要继续解决缓存雪崩的问题。</p>
<p>后来想到一个解决方案，redis的失效时间是一定要设置的，但是我们可以设置一个逻辑失效时间，在value中，我们定义一个时间，当拉取数据时，我们会解析一下，value中的逻辑失效时间是否过期，如果逻辑过期，那我们会单独开一条线程刷新redis失效时间和逻辑失效时间，主线程继续走逻辑，这样可以避免数据的雪崩问题，但是如此解决还是无法根治大量数据失效大量请求打到mysql中，所以我们可以设置一个最终方案，在最后加入rabbitmq，当数据请求到mysql中后，会进入队列，但是走队列的话，会有一个问题，就是数拒响应会延长时间，但是目前来看这是最稳妥的解决方案，如果有更好的解决方案，欢迎私信讨论。</p>
<p>最终，我想到缓存雪崩的解决方案是，redis哨兵+逻辑失效时间+mq</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁</title>
    <url>/2021/04/11/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h4 id="首先redis锁要解决什么？-内含本人使用思考"><a href="#首先redis锁要解决什么？-内含本人使用思考" class="headerlink" title="首先redis锁要解决什么？(内含本人使用思考)"></a>首先redis锁要解决什么？(内含本人使用思考)</h4><ul>
<li>互斥性：任意时刻只能有一个客户端获取锁，不能同时有两个客户端获取到锁；</li>
<li>安全性：锁只能被持有的客户端删除，不能由其他客户端删除；</li>
<li>死锁：获取锁的客户端因为某些原因而宕机而未能释放锁，其他客户端再也无法获取到该锁导致的死锁，此时需要有机制来避免问题的发生；</li>
<li>容错：当部分节点如redis某些节点宕机时，客户端仍然能够获取锁和释放锁</li>
</ul>
<span id="more"></span>

<h4 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h4><p>如果key不存在，则创建并赋值（set if not exist）<br>时间复杂度：O(1)<br>返回值：设置成功，返回1；设置失败，返回0</p>
<p>setnx是原子性的，初期时候被人们用来实现分布式锁。在执行某段代码时候可以先尝试使用setnx，为某个key设值。如果设置成功，则证明此时没有别的线程在执行该段代码，或者说占用该独占资源，这个时候我们线程就可以顺利地去执行该段代码逻辑，如果设置失败，则证明此时有别的程序或者线程占用该资源。那么当前线程就需要等待，直至setnx成功。</p>
<h4 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h4><p>为给定key设置生存时间，当key过期时（生存时间为0），会被自动删除<br>缺点：原子性得不到满足<br>假设setnx执行成功后就直接宕机，来不及expire，此时key就会被一直占用着，意味着其他线程永远也执行不了独占的资源逻辑了，这样就违背了利用redis操作的原子性。</p>
<h4 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h4><p>EX second：设置键的过期时间为second秒<br>PX millisecond：设置键的过期时间为millisecond毫秒<br>NX：只在键不存在时，才对键进行设置操作<br>XX：只在键已经存在时，才对键进行设置操作<br>SET操作成功完成时，返回OK，否则返回(nil)</p>
<h4 id="大量的key同时过期的注意事项："><a href="#大量的key同时过期的注意事项：" class="headerlink" title="大量的key同时过期的注意事项："></a>大量的key同时过期的注意事项：</h4><p>如果大量的key过期时间设置的过于集中，到过期的时间点，由于删除key是需要时间的，redis可能会因为一次性大量删除key出现短暂卡顿现象，面对这种情况解决方法为：在设置key的过期时间上加一个随机值，使过期时间分散一些，这样可在很大程度上避免卡顿的发生。</p>
<h5 id="本人项目中应用事件"><a href="#本人项目中应用事件" class="headerlink" title="本人项目中应用事件"></a>本人项目中应用事件</h5><p>需求如下，项目中，有一个api是生成一个excel表格，每个user只能生成一次excel，但是，当有两个人，用同一个user请求api时，会生成两次excel，此时我的解决方案是，使用redis，通过将key设置为userId，每次请求前，先查看redis中是否有此key，如果有，则返回生成中，如果没有，则SET一个key设置失效时间并向下进行，待完成后，DELETE此key。但是此方法有一个致命的问题，当进程a先锁住后，生成过程中遇到了问题，进程卡住，当失效时间达到后，锁失效，进程B就会开始执行，当进程B执行一半后，进程A执行完毕，数据生成成功，将状态修改为已生成，此时因为redis中还有跟他一样的key，所以删除锁，这时，进程B运行完成，但却发现状态已经被修改，此时会触发报错。</p>
<p>想到的解决方案是，在vaue中存一个uuid，每次生成key之前生成一个uuid，存入value中，当运行结束后，先判断redis中是否有当前的key，如果有的话，则对比value中uuid是否为自己的uuid，如果不是，则本次逻辑作废，返回生成失败，反之成功。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建对象的四种方式</title>
    <url>/2021/03/11/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>new对象</li>
<li>反射，使用Java.lang.Class或者java.lang.reflect.Construrctor</li>
<li>调用对象clone()，注意clone() 有深度和浅度。</li>
<li>反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/04/11/HashMap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架中，创建对象的三种方式</title>
    <url>/2021/03/12/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>无参构造器</li>
<li>静态工厂</li>
<li>实例工厂</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List</title>
    <url>/2021/04/11/List%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>首先，List集合中有几个子类，分别是ArraryList，Vector，LinkList。下面我先现主要说一下最常用的ArrayList。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>线程不安全，为什么呢？通过源码我们可以看到，它没有加Synchronized线程锁。其次他是<strong>有序</strong>的，查询快，但不利于经常修改的场景。</p>
<p><strong>原因：</strong></p>
<p>ArrayList中数据在内存中是连续的成块的，所以查询时候，直接遍历内存即可，插入或者删除时，需要把该节点之后的所有数据全都遍历一遍，为什么说是连续成块的呢？因为ArrayList底层实现为数组。</p>
<p><img src="I:\blog\source\image-20210411225555431.png" alt="image-20210411225555431"></p>
<p>ArraryList的扩容机制(自动扩容)</p>
<p>ArrayList源码中的grow()方法，在ArrayList执行插入时，如果容量不足，会扩容1.5倍</p>
<p><img src="I:\blog\source\image-20210411230127426.png" alt="image-20210411230127426"></p>
<p>List的最顶层是Collection类</p>
<p><img src="I:\blog\source\image-20210411230238064.png" alt="image-20210411230238064"></p>
<h5 id="ArrayList集合的特点："><a href="#ArrayList集合的特点：" class="headerlink" title="ArrayList集合的特点："></a>ArrayList集合的特点：</h5><ul>
<li>ArrayList基于数组实现，是一个动态数组，可自动增长</li>
<li>ArrayList线程不安全，因为没有加锁</li>
<li>ArrayList实现了serializable接口，因此它支持序列化</li>
<li>它实现了RandomAccess接口，支持快速随机访问</li>
<li>实现了Cloneable接口，能被clone</li>
</ul>
<h4 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h4><p><strong>定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; demo = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; def = <span class="keyword">new</span> LinkedList&lt;&gt;(demo);</span><br><span class="line"><span class="comment">//可以直接传递已有集合</span></span><br></pre></td></tr></table></figure>

<p>LinkList内部使用基于链表的数据结构存储，LinkList有一个内部类作为存放元素的单元，里面有三个属性，用来存放元素本身以及前后两个单元的引用，另外LinkList内部有一个header属性，用来表示起始位置。</p>
<p>LinkList是采用双向链表实现的，所以它也具有链表的特点，每一个元素的地址不连续，通过引用找到当前节点上的一个节点和下一个节点，即插入和删除效率比较高，而get和set则较为低效</p>
<p><strong>LinkList的扩容机制：</strong></p>
<p>它的扩容机制是添加多少增长多少。</p>
<h4 id="ArrayList和LinkList的区别"><a href="#ArrayList和LinkList的区别" class="headerlink" title="ArrayList和LinkList的区别"></a>ArrayList和LinkList的区别</h4><ul>
<li>ArrayList是基于动态数组的数据结构，LinkList是基于链表的数据结构。</li>
<li>对于随机访问元素，ArrayList获取时间复杂度是O(1),但是删除数据确实开销很大的，因为需要重排数组中所有的数据，ArrayList想要get(index)时，直接返回index位置上的元素，而LinkList需要通过for循环进行查找，虽然LinkList已经在查找中做了优化，但还是较慢。</li>
<li>对于添加或删除操作，add()和remove()，LinkList更快，首先因为LinkList底层是双向链表结构，不需要改变数组大小，也没有自动扩容，这是ArrayList的缺点，它的时间复杂度为O(n),而LinkList的时间复杂度为O(1).ArrayList在插入数据时还需要更新索引，ArrayList在插入或删除时主要好事的是System.arraycopy()动作，它会移动index后面所有的元素，LinkList耗时的是要先通过for循环找到index，然后直接插入或删除，所以无法对比两者谁的性能更好，只能说更合适哪种。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大部分情况下，ArrayList更受欢迎，但是有些情况下LinkList更优秀。</p>
<ul>
<li>当不需要随机读取第n个元素时。</li>
<li>不需要大量的插入或者删除时</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
