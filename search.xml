<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单例模式</title>
    <url>/2021/03/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Java的设计模式一共有23中，今天我们说单例模式，单例模式是一种最常见的设计模式，在springmvc中bean的注入使用的就是单例模式。</p>
<p>单例模式，只能存在一个实例，并且自己创建自己的对象，这个类提供了一个访问这个对象的唯一方式，可直接访问，不需要通过new来创建一个新的对象，单例模式一共有五种创建方式，下面分别查看这几种方式。</p>
<span id="more"></span>

<p><strong>单例模式的优点：</strong></p>
<ol>
<li>内存中只有一个对象，节省内存空间。</li>
<li>避免频繁的创建销毁对象，可以提高性能。</li>
<li>避免对共享资源的多重占用，简化访问。</li>
<li>为整个系统提供一个全局访问点。</li>
</ol>
<p><strong>单例模式的缺点：</strong></p>
<ol>
<li>不适用于变化频繁的对象。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现的链接池溢出。</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象时垃圾而被回收，这可能会导致对象状态的丢失。</li>
</ol>
<h4 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LanHan&#123;</span><br><span class="line">    private static LanHan lan;</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private LanHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;判断，当没有创建过对象的时候才会创建新对象</span><br><span class="line">    public static LanHan getLan()&#123;</span><br><span class="line">        if(lan&#x3D;&#x3D;null)&#123;</span><br><span class="line">            lan &#x3D; new LanHan;</span><br><span class="line">        &#125;</span><br><span class="line">        return lan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式，只有在使用的时候才会创建</p>
<p><strong>优点：</strong>节省内存空间，只有在真正调用的时候才会实例化对象并调用。</p>
<p><strong>缺点：</strong>只能在单线程情况下使用，在多线程情况下，一个线程进行if else 判断的时候还没有进行运算完成，接下来的线城也进入判断，这样便会创建了多个实例，违背了单例模式的设计意义，并且，严格意义上来说，懒汉式并不属于单例模式</p>
<h4 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EHan&#123;</span><br><span class="line">    &#x2F;&#x2F;创建自己的私有静态对象</span><br><span class="line">    private static EHan eh &#x3D; new EHan();</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;返回自己实例的静态公有方法</span><br><span class="line">    public EHan getEH()&#123;</span><br><span class="line">        return en;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式，在初始化时已经创建好，不管是否调用</p>
<p><strong>优点：</strong>在整个生命周期只会被加载一次，只会创建一个实例，这种写法很简单，避免了线程同步的问题</p>
<p><strong>缺点：</strong>在类装载的时候就完成实例化，如果始终没有调用的话，会浪费内存</p>
<h4 id="3-双重加锁机制"><a href="#3-双重加锁机制" class="headerlink" title="3.双重加锁机制"></a>3.双重加锁机制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class twoLwtion&#123;</span><br><span class="line">    private static twoLwtion instance;</span><br><span class="line">     private static readonly object syncRoot &#x3D; new object();</span><br><span class="line">        private twoLwtion() &#123; &#125;</span><br><span class="line">        public static twoLwtion GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;先判断是否存在，不存在再加锁处理</span><br><span class="line">            if (instance &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;在同一个时刻加了锁的那部分程序只有一个线程可以进入</span><br><span class="line">                lock (syncRoot)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong>lock锁</p>
<p>Double-Check概念，进行了两次if检测，这样可以保证线程安全，这样实例化代码只用执行一次，后面再次访问时，判断singleton==null直接返回实例化对象</p>
<p>使用双重检测同步延迟加载去创建单例模式是一种非常优秀的做法，不但保持了单例，还切实提高了程序运行效率</p>
<p><strong>优点：</strong>线城安全，延迟加载，效率高</p>
<h4 id="4-静态初始化"><a href="#4-静态初始化" class="headerlink" title="4.静态初始化"></a>4.静态初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class staticleton &#123; </span><br><span class="line">    private staticleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      public static staticleton getInstance()&#123;  </span><br><span class="line">        return Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class Inner &#123;  </span><br><span class="line">        private static final Singleton instance &#x3D; new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p>
<p><strong>优点：</strong>利用了classloader机制来保证初始化instance时只有一个线程，线程安全且没有性能损耗</p>
<h4 id="5-枚举单例模式"><a href="#5-枚举单例模式" class="headerlink" title="5.枚举单例模式"></a>5.枚举单例模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;doSomething 该实例支持的行为</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;可以省略此方法，通过Singleton.INSTANCE进行操作</span><br><span class="line">    public static Singleton get Instance() &#123;</span><br><span class="line">        return Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类单例模式是日常开发中比较少用到的单例模式，原因是可读性较差</p>
<p><strong>优点：</strong>不仅可以解决多线程同步问题，还能有效防止反序列化重新创建新的对象</p>
<p><strong>缺点：</strong> jdk1.5中加入了enum，不常用，并且可读性差</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>目前来说，比较推荐的是静态内部类单例模式</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2021/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>整个操作看成为一个整体，要么成功，要么失败，有一个回滚机制</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>这里涉及到了数据库锁<br>排他锁<br>X锁，写锁<br>共享锁<br>S锁，读锁<br>可能会有多个线程同时访问同一条数据，这样数据库会出现一条数据多方调用，这么做会产生数据的更新丢失，<br>为了压制数据更新丢失，数据库标准提出了四类隔离级别</p>
<span id="more"></span>

<h5 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h5><p>未提交读是最低的隔离级别，他允许一个事务读取另一个事务未提交的数据，未提交读是一种非常危险的隔离级别<br><strong>优点</strong><br>并发能力高，适用对数据一致性没有高要求的并发场景<br><strong>缺点</strong><br>会产生脏读<br>脏读的场景为在一条事务未提交时，令一条事务访问了当前事务的数据，但是当前事务数据回滚了，这时，读取到的事务就成为脏读</p>
<h5 id="读写提交"><a href="#读写提交" class="headerlink" title="读写提交"></a>读写提交</h5><p>在事务A进行的时候，事务B不会读取到事务A的任何数据<br><strong>优点</strong><br>读取事务不需要担心其他事务回滚而产生的脏读数据<br><strong>缺点</strong></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>当数据库数据只剩一个的情况下，事务A先扣除库存，这时事务B也进行扣除库存，因为无法读取事务A的操作，所以事务B判断可以扣除库存，这时事务A提交了数据,之后事务B提交数据就会提交失败，因为此时库存为0无法扣除<br>一般发生在delete和update中</p>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>在一个事务进行操作的时候，其他事务不允许读取当前数据库，要等待当前事务提交后才能进行读取，但是在一个事务中多次查询的结果是一致的<br><strong>优点</strong><br>可以完美的避开不可重复读的问题<br><strong>缺点</strong><br>幻读<br>发生在insert中<br>当事务A中有两条select语句，当执行完第一条select语句口，事务B对数据库进行了操作，添加了一条数据，这时事务A第二条select查看就会发现多了一条之前没有查到的数据<br>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。<br>解决方案，innodb数据库引擎已经解决当前问题<br>Innodb引入间隙锁</p>
<h5 id="串行话"><a href="#串行话" class="headerlink" title="串行话"></a>串行话</h5><p>这个是数据库的最高隔离级别，当一个事务执行时，其他事务都要排队，按顺序一个一个的进行<br>缺点<br>会产生数据的冗余</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>当整个事务执行完毕后，所有数据都会被固化到磁盘中，供长期的访问</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务在完成时，必须使所有事务都保持一致</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>装箱拆箱</title>
    <url>/2021/03/10/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="装箱-java中将这个机制设置为自动"><a href="#装箱-java中将这个机制设置为自动" class="headerlink" title="装箱(java中将这个机制设置为自动)"></a>装箱(java中将这个机制设置为自动)</h2><ul>
<li>装箱的概念为将基本数据类型转换为包装类型</li>
<li>构造函数：可用于将基本类型转换为包装器类型</li>
<li>valueOf()：可用于将基本类型转换为包装器类型</li>
<li>自动装箱<ul>
<li><p>int x= 1; Integer y = x;</p>
</li>
<li><p>public void demo(Integer a){} int x = 1; demo(x);</p>
<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="拆箱-java中将这个机制设置为自动"><a href="#拆箱-java中将这个机制设置为自动" class="headerlink" title="拆箱(java中将这个机制设置为自动)"></a>拆箱(java中将这个机制设置为自动)</h2><ul>
<li>拆箱的概念为将包装器类型转换成基本数据类型</li>
<li>byteValue()、shortValue()等xxxValue()方法：可用于将包装器类型转换为基本数据类型</li>
<li>parseInt()等parseXxx()方法：可用于将String对象转换为基本数据类型</li>
<li>toString()方法：由Object对象继承而来，用于将包装器类型转换为String类型</li>
<li>自动拆箱<ul>
<li>Integer x = new Integer(1); int y = x ;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/03/10/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存（缓存雪崩，缓存击穿，缓存穿透）"><a href="#缓存（缓存雪崩，缓存击穿，缓存穿透）" class="headerlink" title="缓存（缓存雪崩，缓存击穿，缓存穿透）"></a>缓存（缓存雪崩，缓存击穿，缓存穿透）</h1><p><strong>首先</strong>，什么是缓存，在计算机中，数据的运行方式是 CPU&gt;内存&gt;储存，所以内存是直接与cpu交流的，最接近CPU的，所以内存的效率是很高的，但是，内存是RAM，也就是说，当机器停机或断电情况下，内存会全部消失。</p>
<span id="more"></span>

<p>在日常开发中我们使用的缓存一般是指redis缓存数据库，redis的细节在此不做讲解，后续会出一篇redis的文章，在此篇文章中主要介绍缓存雪崩，缓存击穿，缓存穿透这三个问题。</p>
<p> 我们为什么要在项目中添加缓存，直接用数据库查询不好么？一条sql直接搞定，这是我在刚接触到缓存的时候想的问题，为什么呢，首先，缓存有两个主要的用途：<strong>高性能，高并发</strong>，现在是一个高并发的时代，会有很多人同时操作我们的项目，这时，数据库能承受多少的访问量呢？一条sql的select查询需要多久呢？每次我们操作都需要去数据库查询一遍相同的数据是不是重复操作呢？这些重复操作会浪费掉我们多少的性能呢？当有人恶意访问把我们的数据库查崩了会怎么样呢？等等好多的问题，都指向了缓存。</p>
<p>首先，redis数据库是非关系型数据库，一个key一个value，当我们在项目中加入缓存后，第一个人查询完，第二个人直接去缓存中拿这个数据，不需要再走一遍sql，最简单的例子，一条sql查询某个数据需要300ms，而你将这些数据放入到redis中，下次通过这个key进行查询的时候只需要3ms就可以查询出来。在高并发的情况下，mysql天然支持不是很好，当然也不是非说不可以，假如在我们的项目中，某个时间段，一秒钟有一万个请求，那么单个mysql的项目绝对会垮掉，这时候只要我们加上缓存，把大量的数据都放进缓存中，单个redis就可以轻松支撑每秒几万到几十万的数据，他的承载并发量是mysql的几十倍。</p>
<p>接下来步入正题，使用缓存后我们会遇到的第一个问题，缓存雪崩，缓存击穿，缓存穿透，这三种最常见的地方就是在电商项目中。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><strong>场景</strong><br>同一时间下有大量的数据同时失效，这时会对数据库产生庞大的压力<br>双十一十二点，大量用户访问商品，加入商品有效时间为一小时，一点后，所有缓存全部到期，这时就会触发缓存雪崩</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>高可用：</strong> redis主从复制和redis集群，redis 集群有哨兵和Cluster等，此处不做详细讲解</p>
<p><strong>限流降级：</strong> 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>随机过期时间：</strong> 将缓存的有效时间设置为随机数，每个缓存的失效时间都不相同，这样就可以有效的解决缓存雪崩</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>场景</strong><br>在大数据量的访问时，缓存失效了，这时会有大量请求直接击穿数据库，这就是缓存击穿<br>在淘宝中，一个商品卖成了热卖商品，在热卖的过程中，缓存失效了，这时一瞬间就会触发缓存雪崩问题</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>添加互斥锁</p>
<p>将热卖商品的缓存过期时间设置为永不过期</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>场景</strong><br>当有人知道当前请求的路径后，多次请求并不存在的数据，这样就会使请求直接穿透到数据库上，导致数据库压力过大<br>一个人恶意请求数据，疯狂发送不存在的数据，这时会产生缓存穿透</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>创建黑名单，将数据库不存在的数据存入到缓存黑名单中，每次访问，如果传参在黑名单中，则将黑名单中信息直接返回给请求者，这样可以避免数据走数据库</p>
<p>本人也在学习阶段，如有哪里写的有问题欢迎指点，不喜勿喷</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>redis为什么要配置连接池</title>
    <url>/2021/03/23/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>​        昨天面试的时候被问了一个问题，redis效率这么高为什么还要配置连接池，当时蒙了，后来查询原来是这样的。</p>
<p>​         redis以高性能著称，但是我们在日常使用中，需要将项目和redis进行连接操作，并且也会有redis和项目不在一个服务器中的情况，当我们调用redis时，假如耗时30ms，那么redis的响应和处理时间有可能才占1ms，剩下的29ms全都是链接所消耗的时间，所以，我们配置连接池，连接池中会一直保持几个链接，当项目需要时直接调用，节省连接时间，提升性能</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池之Druid--配置篇</title>
    <url>/2021/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B9%8BDruid/</url>
    <content><![CDATA[<p>日常开发中数据库是我们都要使用的，使用数据库也就意味着必须建立项目和数据之间的联系，所以我们需要使用数据库连接池，目前我选择使用druid连接池，该连接池是阿里开源的，功能非常强大，最大的特点是可以监控sql和可视化界面，目前各种数据库连接池的特点如下图所示</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210330202641268.png" alt="image-20210330202641268"></p>
<p><strong>步入正题</strong></p>
<span id="more"></span>

<p>druid有两种配置方式，阿里开源框架中为了springboot提供了封装好的引用包和druid原生的包，分别为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此依赖为druid原生的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 此依赖为springboot--druid的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-引用springboot-druid的配置"><a href="#1-引用springboot-druid的配置" class="headerlink" title="1. 引用springboot-druid的配置"></a>1. 引用springboot-druid的配置</h2><p>引用springboot-druid包后，当前包中已经为我们配置好了配置文件的映射方法，所以我们只需要在配置文件中添加配置就好，配置文件如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#以下为druid增加的配置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化时建立物理连接的个数</span><br><span class="line">spring.datasource.druid.initial-size=50</span><br><span class="line"># 最小连接池数量</span><br><span class="line">spring.datasource.druid.min-idle=50</span><br><span class="line"># 最大连接池数量</span><br><span class="line">spring.datasource.druid.max-active=10</span><br><span class="line"># 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁</span><br><span class="line">spring.datasource.druid.max-wait=60000</span><br><span class="line"># 有两个含义：</span><br><span class="line">#1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。</span><br><span class="line">#2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</span><br><span class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</span><br><span class="line"># 连接保持空闲而不被驱逐的最小时间</span><br><span class="line">spring.datasource.druid.min-evictable-idle-time-millis=30000</span><br><span class="line"># 用来检测连接是否有效的SQL,如果未null,testOnBorrow,testOnReturn,testWhileIdle不会起作用</span><br><span class="line">spring.datasource.druid.validation-query=SELECT 1</span><br><span class="line"># 检测链接是否有效的超时时间,单位秒;底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</span><br><span class="line">spring.datasource.druid.validation-query-timeout=10</span><br><span class="line"># 建议配置为true,不影响性能,并且保证安全性.申请连接的时候检测,如果空闲时间大于timeBetweenEvictionRunsMills,执行validationQuery检测连接是否有效.</span><br><span class="line">spring.datasource.druid.test-while-idle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-borrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-return=false</span><br><span class="line"># 是否缓存preparedStatement,即PSCache,PSCache对支持游标的数据库性能提升巨大,如oracle,mysql下建议关闭</span><br><span class="line">spring.datasource.druid.pool-prepared-statements=false</span><br><span class="line"># 要启用PSCache,必须配置大于0,当大于0时,上面配置自动修改为true;Druid中不会存在Oracle下PSCache占用内存过多的问题,可以把数值配置大一些,如100</span><br><span class="line">spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20</span><br><span class="line">spring.datasource.druid.filter.stat.enabled=true</span><br><span class="line">spring.datasource.druid.filter.stat.merge-sql=true</span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=5000</span><br><span class="line">#WebStatFilter监控配置</span><br><span class="line"># 这个教程很保姆,参考https://blog.csdn.net/qq_45173404/article/details/109075810</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=100</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line">#页面登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class="line">#页面登录用户密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br></pre></td></tr></table></figure>

<h2 id="2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"><a href="#2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式" class="headerlink" title="2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"></a>2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式</h2><p> 配置类如下所述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  主要实现WEB监控的配置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在要进行druid监控的配置处理操作</span></span><br><span class="line">        ServletRegistrationBean servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">                <span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 白名单,多个用逗号分割， 如果allow没有配置或者为空，则允许所有访问</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;127.0.0.1,172.29.32.54&quot;</span>);</span><br><span class="line">        <span class="comment">// 黑名单,多个用逗号分割 (共同存在时，deny优先于allow)</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;deny&quot;</span>, <span class="string">&quot;192.168.1.110&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理用户名</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理密码</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;eju1314&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否可以重置数据源，禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean() ;</span><br><span class="line">    filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">    <span class="comment">//所有请求进行监控处理</span></span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>); </span><br><span class="line">    <span class="comment">//添加不需要忽略的格式信息</span></span><br><span class="line">    filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.css,/druid/*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完配置类后，我们的配置文件中配置如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.name=dev</span><br><span class="line"># 基本属性</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line"># 可以不配置，根据url自动识别，建议配置</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#=================================以下为druid增加的配置==========================</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化连接池个数</span><br><span class="line">spring.datasource.initialSize=5</span><br><span class="line"># 最小连接池个数——》已经不再使用，配置了也没效果</span><br><span class="line">spring.datasource.minIdle=2</span><br><span class="line"> # 最大连接池个数</span><br><span class="line">spring.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间，单位毫秒，缺省启用公平锁，并发效率会有所下降</span><br><span class="line">spring.datasource.maxWait=60000</span><br><span class="line"> # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">spring.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">spring.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line">spring.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line"># 建议配置为true，不影响性能，并且保证安全性。</span><br><span class="line"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span><br><span class="line">spring.datasource.testWhileIdle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnBorrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">spring.datasource.poolPreparedStatements=true</span><br><span class="line">spring.datasource.maxPoolPreparedStatementPerConnectionSize=20</span><br><span class="line"># 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有： </span><br><span class="line"># 监控统计用的filter:stat</span><br><span class="line"># 日志用的filter:log4j</span><br><span class="line"># 防御sql注入的filter:wall</span><br><span class="line">spring.datasource.filters=stat,wall,log4j</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">spring.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven如何使项目打包时排除指定的依赖</title>
    <url>/2021/03/30/maven%E5%A6%82%E4%BD%95%E4%BD%BF%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%97%B6%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>打包时，需要将项目中的一些依赖排除出去，查询后使用代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.58.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，使用了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此命令行可以使下项目打包时不将该依赖打包进去。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
