<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap</title>
    <url>/2021/03/12/HashMap/</url>
    <content><![CDATA[<p>我们在日常使用中，最常见的Map集合就是HashMap，但HashMap的存储结构是什么样的，这个在初学的时候很少会有人思考。下面我们便开始深入了解HashMap集合。</p>
<span id="more"></span>

<p><strong>数据结构：</strong></p>
<ul>
<li>HashMap是一个数组+链表+红黑树的结构组成。</li>
<li>HashMap初始长度为16，之后每次自动扩容都是原来的两倍。</li>
<li>HashMap是基于Hash表实现的，每个元素都是一个key-value，内部通过单链表解决冲突，容量不足时自动增长。</li>
<li>HashMap时为线程安全的，只适用于单线程环境下</li>
<li>HashMap实现了serializable接口，因此它支持序列化，实现了Cloneable，能被克隆。</li>
<li>HashMap可以有一个key等于null，value等于null的数据，排在下标为第一个的位置</li>
<li>HashMap在计算hash值中，将key的hashcode进行了2次hash，以获得更好的散列值，然后对table数组长度取模。</li>
</ul>
<p><strong>hashMap是如何解决hash冲突问题的：</strong></p>
<ul>
<li><p>Map中有一个内部接口Map.Entry,其实它就是一个key-value，当系统决定存储HashMap的key-value时，完全没有考虑Entry中的value，仅仅只是将value当成key的附属，在HashMap没有出现hash冲突时，没有形成单链表时，HashMap查找元素很快，get()能够直接定位到元素，但是，当出现单链表之后，单个bucket里存储的不是一个Entry，而时一个Entery链，系统只能必须按顺序遍历每个Entry，直到找到Entry为止。</p>
</li>
<li><p>HashMap数据结构图：</p>
</li>
<li><p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/qwerrrr.jpg?Expires=1618752477&OSSAccessKeyId=TMP.3KioeBxRkdq2NaeZHzdxqDq3XXHQAv7Y19EeLbdaExZfH2umzHyZ1tqjTei6GMUzFosMjRwCJqmPFyCR3oqszyWEVTFeRU&Signature=KDZZ7/RwP0anzXr8apycnAxS5SE=" alt="文件无法预览。"></p>
</li>
<li><p>table是hash数组，数组的每个元素的，欧式一个单链表的头节点，链表是用来解决冲突的，当多个不同的key映射到数组的同一位置时，就将其放入到单链表中。</p>
</li>
<li><p>在HashMap插入时，如果key.hash()相等时，如果判断是否覆盖呢？</p>
<ul>
<li>在hashcode相同后，会调用equales()进行判断，两者是否为同一对象。</li>
<li>equels()默认是对比内存地址，因此Java强调重写equels()时，重写hashcode()</li>
</ul>
</li>
</ul>
<p>红黑树时jdk8中对HashMap的一个变更，在JDK7之前，HashMap采用数组链表的形式存储数据，我们知道，优秀的hash算法应避免碰撞的发生，假如开发者使用了错误的hash算法O(1)级别的数组查询退化到O(n)级别的数组查询退化到O(n)级别的链表查询，因此JDK8中引入了红黑树，当一个结点的链表长度小于6时，链表会转换成红黑树，提高查询效率，当长度小于6时，又会退回到链表结构。</p>
<p><strong>HashMap为什么用的是Object类型？</strong></p>
<p>首先我们要想，hashmap的数据结构是什么？数组+链表+红黑树</p>
<p>存储元素时，用的是hash表存储，每存储一个对象，都会调用hashcode()方法算出hash值，这里就是重点，基本数据类型是无法调用hashcode()方法的，但是所有的包装类都可以，而最后Object是所有包装类的父类。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>InputStream与OutPutStream的相互转换</title>
    <url>/2021/04/29/InputStream%E4%B8%8EOutPutStream%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ConcurrentHashMap(一)</title>
    <url>/2021/04/09/ConcurrentHashMap-%E4%B8%80/</url>
    <content><![CDATA[<p>当我们提到Map集合的时候，我们第一想法都是HashMap和HashTable，但是HashMap和HashTable都有自己的缺点。</p>
<p>首先HashMap它跟HashTable比，HashMap因为没有加锁，所以它的效率很高，但同时，它在多线程环境下，它无法保证数据同步，反之HashTable加了锁，但是同时也使它的效率降低，所以，在jdk1.5中加入了ConcurrentHashMap，但是ConcurrentHashMap发扬光大的还是在jdk1.7和1.8版本中，这两个版本的ConcurrentHashMap有着非常巨大的区别，本章我们先初步介绍这两个版本的ConcurrentHashMap。</p>
<h2 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h2>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建对象的四种方式</title>
    <url>/2021/03/11/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>new对象</li>
<li>反射，使用Java.lang.Class或者java.lang.reflect.Construrctor</li>
<li>调用对象clone()，注意clone() 有深度和浅度。</li>
<li>反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法间调用到底是引用传递还是值传递？</title>
    <url>/2021/04/26/Java%E6%96%B9%E6%B3%95%E9%97%B4%E8%B0%83%E7%94%A8%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/</url>
    <content><![CDATA[<p>方法之间参数传递到底是值传参还是引用传参？</p>
<p>我们先看一段代码</p>
<p><img src="https://api2.mubu.com/v3/document_image/536d8f76-57f7-479a-9ab7-c7ebd921b3c0-3660795.jpg" alt="img"></p>
<p><img src="https://api2.mubu.com/v3/document_image/caa7a274-4383-46f4-9cc6-0f1f5e89157f-3660795.jpg" alt="img"></p>
<p>通过上面两个截图，我们可以看到传过来的地址是一个地址，并且我们看下图</p>
<p><img src="https://api2.mubu.com/v3/document_image/96ce7e65-ac10-435a-9fc2-fbac56b2b47c-3660795.jpg" alt="img"></p>
<p>可以看到，在主函数中我并没有接收返回值，但是打印出来的值是修改后的值，所以根据上述两点我们可以证明，方法间传输是引用传参，但是全都是引用传参吗？我们又进行下图操作</p>
<p><img src="https://api2.mubu.com/v3/document_image/b231aae8-346b-4394-873b-118c5ab331ec-3660795.jpg" alt="img"></p>
<p>当我们使用int的时候，发现值并没有传过来，这是为什么？</p>
<p>首先我们要清楚什么是值传参什么是引用传参。</p>
<p><strong>值传参：</strong>值传参，只传递内容，完全独立</p>
<p><strong>引用传参：</strong>引用传参，每个对象在Java中都有自己的地址，这个地址是内容存储在堆内存中的，每次我们传递的都是这个地址，接收后的操作也都是对这个地址操作，大家共同使用一个地址，数据同步。</p>
<p>那么int，是基本数据类型，无法创建对象，内容是存储在常量池中，所以没有地址，所以传输为值传递</p>
<p>然而所有的引用类型都是一个对象，有自己的地址，所以每次传递都是引用传递</p>
<p><strong>结论:</strong></p>
<p>当对象调用时，如果我们使用的是引用对象，那么为引用传递，如果我们使用的是基本数据类型，则为值传递</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List</title>
    <url>/2021/03/11/List%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>首先，List集合中有几个子类，分别是ArraryList，Vector，LinkList。下面我先现主要说一下最常用的ArrayList。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>线程不安全，为什么呢？通过源码我们可以看到，它没有加Synchronized线程锁。其次他是<strong>有序</strong>的，查询快，但不利于经常修改的场景。</p>
<span id="more"></span>

<p><strong>原因：</strong></p>
<p>ArrayList中数据在内存中是连续的成块的，所以查询时候，直接遍历内存即可，插入或者删除时，需要把该节点之后的所有数据全都遍历一遍，为什么说是连续成块的呢？因为ArrayList底层实现为数组。</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210411225555431.png" alt="image-20210411225555431"></p>
<p>ArraryList的扩容机制(自动扩容)</p>
<p>ArrayList源码中的grow()方法，在ArrayList执行插入时，如果容量不足，会扩容1.5倍</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210411230127426.png" alt="image-20210411230127426"></p>
<p>List的最顶层是Collection类</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210411230238064.png" alt="image-20210411230238064"></p>
<h5 id="ArrayList集合的特点："><a href="#ArrayList集合的特点：" class="headerlink" title="ArrayList集合的特点："></a>ArrayList集合的特点：</h5><ul>
<li>ArrayList基于数组实现，是一个动态数组，可自动增长</li>
<li>ArrayList线程不安全，因为没有加锁</li>
<li>ArrayList实现了serializable接口，因此它支持序列化</li>
<li>它实现了RandomAccess接口，支持快速随机访问</li>
<li>实现了Cloneable接口，能被clone</li>
</ul>
<h4 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h4><p><strong>定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; demo = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; def = <span class="keyword">new</span> LinkedList&lt;&gt;(demo);</span><br><span class="line"><span class="comment">//可以直接传递已有集合</span></span><br></pre></td></tr></table></figure>

<p>LinkList内部使用基于链表的数据结构存储，LinkList有一个内部类作为存放元素的单元，里面有三个属性，用来存放元素本身以及前后两个单元的引用，另外LinkList内部有一个header属性，用来表示起始位置。</p>
<p>LinkList是采用双向链表实现的，所以它也具有链表的特点，每一个元素的地址不连续，通过引用找到当前节点上的一个节点和下一个节点，即插入和删除效率比较高，而get和set则较为低效</p>
<p><strong>LinkList的扩容机制：</strong></p>
<p>它的扩容机制是添加多少增长多少。</p>
<h4 id="ArrayList和LinkList的区别"><a href="#ArrayList和LinkList的区别" class="headerlink" title="ArrayList和LinkList的区别"></a>ArrayList和LinkList的区别</h4><ul>
<li>ArrayList是基于动态数组的数据结构，LinkList是基于链表的数据结构。</li>
<li>对于随机访问元素，ArrayList获取时间复杂度是O(1),但是删除数据确实开销很大的，因为需要重排数组中所有的数据，ArrayList想要get(index)时，直接返回index位置上的元素，而LinkList需要通过for循环进行查找，虽然LinkList已经在查找中做了优化，但还是较慢。</li>
<li>对于添加或删除操作，add()和remove()，LinkList更快，首先因为LinkList底层是双向链表结构，不需要改变数组大小，也没有自动扩容，这是ArrayList的缺点，它的时间复杂度为O(n),而LinkList的时间复杂度为O(1).ArrayList在插入数据时还需要更新索引，ArrayList在插入或删除时主要好事的是System.arraycopy()动作，它会移动index后面所有的元素，LinkList耗时的是要先通过for循环找到index，然后直接插入或删除，所以无法对比两者谁的性能更好，只能说更合适哪种。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大部分情况下，ArrayList更受欢迎，但是有些情况下LinkList更优秀。</p>
<ul>
<li>当不需要随机读取第n个元素时。</li>
<li>不需要大量的插入或者删除时</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架中，创建对象的三种方式</title>
    <url>/2021/03/12/Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>无参构造器</li>
<li>静态工厂</li>
<li>实例工厂</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String字符串有没有上限</title>
    <url>/2021/04/01/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E6%B2%A1%E6%9C%89%E4%B8%8A%E9%99%90/</url>
    <content><![CDATA[<p>String字符串到底有没有上限呢？我们通过源码来分析。</p>
<p><strong>首先</strong>，我们需要知道String字符串实际是用什么存储的，在jdk1.6中，String是用byte数组存储的，在jdk1.8中，String是用char[]存储的。</p>
<p>数组，我们是需要可以设置大小的，数组设置大小有两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">12</span>]; <span class="comment">//数组长度为12</span></span><br><span class="line"><span class="keyword">char</span>[] ar = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">//数组长度为5</span></span><br></pre></td></tr></table></figure>

<p>其中，数组长度的定义都为整数，至于为什么是整数类型，我们可以看一下length()这个方法，该方法的返回值是int类型，所以数组长度不可能超过int类型的上限，我们通过Integer的代码中可以看到：</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxValue &#x3D; Integer.MAX_VALUE;</span><br><span class="line">&#x2F;&#x2F;查看MAX_VALUE的源码</span><br></pre></td></tr></table></figure>

<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210401230126446.png" alt="image-20210401230126446"></p>
<p>注释中写道，int的最大值为2^31-1也就是2147483647 = 4GB。</p>
<p>所以String的最大长度应该是2147483647，但是，我们测试一下，创建一个十万个字节长的字符串，使用String a = “”;方式来创建，编译后，jvm报错，提示原因是，字符串长度过长，为什么会这样呢？由此引出了下面的问题，String创建的两种方式。</p>
<p>String字符串有两种创建方式，分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;adasdsdasd&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;asdasda&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这两种创建方式存储的地方是不一样的，字符串a创建后，会存储在常量池中，而字符串s则被存储在堆内存中。</p>
<p><strong>存储在常量池：</strong></p>
<p>常量池中数组的有效长度为0-65535，但是虚拟机还需要一个字节的指令作为结束，所以真正的有效范围为0~65534（至于为什么是这个范围，本文不做解释，后续文章会有所解释），也就是说，通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>创建的字符串，因为是一个常量，所以会被存储在常量池中，存储在常量池的话，就需要被常量池的规则约束，上限为65534个字节的长度，如果拼接字符串的话则不需要遵守这个约束，因为拼接后是一个对象，存储在堆内存中。</p>
<p><strong>存储在堆内存：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;asdasda&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为a字符串是new出来的，所以是一个对象，所以它的值会被存储在堆内存中，在堆内存中的字符串则不需要遵守常量池的约束可以达到整型的最大值。</p>
<p><strong>结论</strong></p>
<p>当字符串在常量池中时，上限为65534。</p>
<p>当字符串为拼接，或者扶着的话范围为整形的最大值。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile</title>
    <url>/2021/04/18/Volatile/</url>
    <content><![CDATA[<p>单例模式中，有一个双重锁模式，双重锁模式中应用到了此关键字，接下来我们对volatile的工作方式进行查看。</p>
<p><strong>volatile写理解：</strong></p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地中的共享变量值刷新到主内存。</li>
</ul>
<span id="more"></span>

<p><strong>volatile读理解：</strong></p>
<ul>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，县城接下来将从主内存中读取主内存的变量</li>
</ul>
<p><strong>volatile指令重排：</strong></p>
<p>volatile变量的内存可见性，是基于内存屏障实现的，JMM内部会有指令重排，并会有af-if-serial跟happen-before的理念来保证指令的正确性，内存屏障就是基于四个汇编级别的关键字来禁止指令重拍的，其中volatile的规则如下：</p>
<ul>
<li>第一个为读操作时，第二个任何操作不可重排序到第一个前面。</li>
<li>第二为写操作时，第一个任何操作不可重排序到第二个后面。</li>
<li>第一个为写操作时，第二个的读写操作也不运行重排序。</li>
</ul>
<p><strong>volatile的两大重要特点：</strong></p>
<p><strong>可见性：</strong></p>
<ul>
<li><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
</li>
<li><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
</li>
<li><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
</li>
<li><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
</li>
</ul>
<p><strong>有序性：</strong></p>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<ul>
<li><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
</li>
<li><p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<ul>
<li>下面就来具体介绍下happens-before原则（先行发生原则）：</li>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
<li>这8条原则摘自《深入理解Java虚拟机》。<ul>
<li>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。下面我们来解释一下前4条规则：<ul>
<li>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</li>
<li>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</li>
<li>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</li>
<li>第四条规则实际上就是体现happens-before原则具备传递性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　使用volatile修饰之后：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<p><strong>volatile的原理和实现机制</strong></p>
<p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁</title>
    <url>/2021/04/11/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h4 id="首先redis锁要解决什么？-内含本人使用思考"><a href="#首先redis锁要解决什么？-内含本人使用思考" class="headerlink" title="首先redis锁要解决什么？(内含本人使用思考)"></a>首先redis锁要解决什么？(内含本人使用思考)</h4><ul>
<li>互斥性：任意时刻只能有一个客户端获取锁，不能同时有两个客户端获取到锁；</li>
<li>安全性：锁只能被持有的客户端删除，不能由其他客户端删除；</li>
<li>死锁：获取锁的客户端因为某些原因而宕机而未能释放锁，其他客户端再也无法获取到该锁导致的死锁，此时需要有机制来避免问题的发生；</li>
<li>容错：当部分节点如redis某些节点宕机时，客户端仍然能够获取锁和释放锁</li>
</ul>
<span id="more"></span>

<h4 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h4><p>如果key不存在，则创建并赋值（set if not exist）<br>时间复杂度：O(1)<br>返回值：设置成功，返回1；设置失败，返回0</p>
<p>setnx是原子性的，初期时候被人们用来实现分布式锁。在执行某段代码时候可以先尝试使用setnx，为某个key设值。如果设置成功，则证明此时没有别的线程在执行该段代码，或者说占用该独占资源，这个时候我们线程就可以顺利地去执行该段代码逻辑，如果设置失败，则证明此时有别的程序或者线程占用该资源。那么当前线程就需要等待，直至setnx成功。</p>
<h4 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h4><p>为给定key设置生存时间，当key过期时（生存时间为0），会被自动删除<br>缺点：原子性得不到满足<br>假设setnx执行成功后就直接宕机，来不及expire，此时key就会被一直占用着，意味着其他线程永远也执行不了独占的资源逻辑了，这样就违背了利用redis操作的原子性。</p>
<h4 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h4><p>EX second：设置键的过期时间为second秒<br>PX millisecond：设置键的过期时间为millisecond毫秒<br>NX：只在键不存在时，才对键进行设置操作<br>XX：只在键已经存在时，才对键进行设置操作<br>SET操作成功完成时，返回OK，否则返回(nil)</p>
<h4 id="大量的key同时过期的注意事项："><a href="#大量的key同时过期的注意事项：" class="headerlink" title="大量的key同时过期的注意事项："></a>大量的key同时过期的注意事项：</h4><p>如果大量的key过期时间设置的过于集中，到过期的时间点，由于删除key是需要时间的，redis可能会因为一次性大量删除key出现短暂卡顿现象，面对这种情况解决方法为：在设置key的过期时间上加一个随机值，使过期时间分散一些，这样可在很大程度上避免卡顿的发生。</p>
<h5 id="本人项目中应用事件"><a href="#本人项目中应用事件" class="headerlink" title="本人项目中应用事件"></a>本人项目中应用事件</h5><p>需求如下，项目中，有一个api是生成一个excel表格，每个user只能生成一次excel，但是，当有两个人，用同一个user请求api时，会生成两次excel，此时我的解决方案是，使用redis，通过将key设置为userId，每次请求前，先查看redis中是否有此key，如果有，则返回生成中，如果没有，则SET一个key设置失效时间并向下进行，待完成后，DELETE此key。但是此方法有一个致命的问题，当进程a先锁住后，生成过程中遇到了问题，进程卡住，当失效时间达到后，锁失效，进程B就会开始执行，当进程B执行一半后，进程A执行完毕，数据生成成功，将状态修改为已生成，此时因为redis中还有跟他一样的key，所以删除锁，这时，进程B运行完成，但却发现状态已经被修改，此时会触发报错。</p>
<p>想到的解决方案是，在vaue中存一个uuid，每次生成key之前生成一个uuid，存入value中，当运行结束后，先判断redis中是否有当前的key，如果有的话，则对比value中uuid是否为自己的uuid，如果不是，则本次逻辑作废，返回生成失败，反之成功。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>maven如何使项目打包时排除指定的依赖</title>
    <url>/2021/03/30/maven%E5%A6%82%E4%BD%95%E4%BD%BF%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%97%B6%E6%8E%92%E9%99%A4%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>打包时，需要将项目中的一些依赖排除出去，查询后使用代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.58.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，使用了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此命令行可以使下项目打包时不将该依赖打包进去。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/2021/04/17/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>redis，缓存类型数据库，高效，单线程，这是我们对redis的第一印象，但是redis，数据存储在缓存中，当突然宕机或者redis重启了，这些数据怎么办？</p>
<p>由此，引出我们接下来的话题，redis，持久化，redis为了防止数据丢失，提出了两套方案，RDB和AOF两种持久化方式，下面我们对这两种持久化方式的实现和使用进行深入了解。</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis为什么要配置连接池</title>
    <url>/2021/03/23/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>​         redis以高性能著称，但是我们在日常使用中，需要将项目和redis进行连接操作，并且也会有redis和项目不在一个服务器中的情况，当我们调用redis时，假如耗时30ms，那么redis的响应和处理时间有可能才占1ms，剩下的29ms全都是链接所消耗的时间，所以，我们配置连接池，连接池中会一直保持几个链接，当项目需要时直接调用，节省连接时间，提升性能</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>transient</title>
    <url>/2021/04/29/transient/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/03/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Java的设计模式一共有23中，今天我们说单例模式，单例模式是一种最常见的设计模式，在springmvc中bean的注入使用的就是单例模式。</p>
<p>单例模式，只能存在一个实例，并且自己创建自己的对象，这个类提供了一个访问这个对象的唯一方式，可直接访问，不需要通过new来创建一个新的对象，单例模式一共有五种创建方式，下面分别查看这几种方式。</p>
<span id="more"></span>

<p><strong>单例模式的优点：</strong></p>
<ol>
<li>内存中只有一个对象，节省内存空间。</li>
<li>避免频繁的创建销毁对象，可以提高性能。</li>
<li>避免对共享资源的多重占用，简化访问。</li>
<li>为整个系统提供一个全局访问点。</li>
</ol>
<p><strong>单例模式的缺点：</strong></p>
<ol>
<li>不适用于变化频繁的对象。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现的链接池溢出。</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象时垃圾而被回收，这可能会导致对象状态的丢失。</li>
</ol>
<h4 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LanHan&#123;</span><br><span class="line">    private static LanHan lan;</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private LanHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;判断，当没有创建过对象的时候才会创建新对象</span><br><span class="line">    public static LanHan getLan()&#123;</span><br><span class="line">        if(lan&#x3D;&#x3D;null)&#123;</span><br><span class="line">            lan &#x3D; new LanHan;</span><br><span class="line">        &#125;</span><br><span class="line">        return lan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式，只有在使用的时候才会创建</p>
<p><strong>优点：</strong>节省内存空间，只有在真正调用的时候才会实例化对象并调用。</p>
<p><strong>缺点：</strong>只能在单线程情况下使用，在多线程情况下，一个线程进行if else 判断的时候还没有进行运算完成，接下来的线城也进入判断，这样便会创建了多个实例，违背了单例模式的设计意义，并且，严格意义上来说，懒汉式并不属于单例模式</p>
<h4 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2.饿汉式"></a>2.饿汉式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EHan&#123;</span><br><span class="line">    &#x2F;&#x2F;创建自己的私有静态对象</span><br><span class="line">    private static EHan eh &#x3D; new EHan();</span><br><span class="line">    &#x2F;&#x2F;私有构造器</span><br><span class="line">    private EHan()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;返回自己实例的静态公有方法</span><br><span class="line">    public EHan getEH()&#123;</span><br><span class="line">        return en;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式，在初始化时已经创建好，不管是否调用</p>
<p><strong>优点：</strong>在整个生命周期只会被加载一次，只会创建一个实例，这种写法很简单，避免了线程同步的问题</p>
<p><strong>缺点：</strong>在类装载的时候就完成实例化，如果始终没有调用的话，会浪费内存</p>
<h4 id="3-双重加锁机制"><a href="#3-双重加锁机制" class="headerlink" title="3.双重加锁机制"></a>3.双重加锁机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong>lock锁</p>
<p>Double-Check概念，进行了两次if检测，这样可以保证线程安全，这样实例化代码只用执行一次，后面再次访问时，判断singleton==null直接返回实例化对象</p>
<p>使用双重检测同步延迟加载去创建单例模式是一种非常优秀的做法，不但保持了单例，还切实提高了程序运行效率</p>
<p><strong>优点：</strong>线城安全，延迟加载，效率高</p>
<p>这里涉及到了一个关键字volatile，请看后续专门讲解的文章</p>
<h4 id="4-静态初始化"><a href="#4-静态初始化" class="headerlink" title="4.静态初始化"></a>4.静态初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class staticleton &#123; </span><br><span class="line">    private staticleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      public static staticleton getInstance()&#123;  </span><br><span class="line">        return Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class Inner &#123;  </span><br><span class="line">        private static final Singleton instance &#x3D; new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p>
<p><strong>优点：</strong>利用了classloader机制来保证初始化instance时只有一个线程，线程安全且没有性能损耗</p>
<h4 id="5-枚举单例模式"><a href="#5-枚举单例模式" class="headerlink" title="5.枚举单例模式"></a>5.枚举单例模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;doSomething 该实例支持的行为</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;可以省略此方法，通过Singleton.INSTANCE进行操作</span><br><span class="line">    public static Singleton get Instance() &#123;</span><br><span class="line">        return Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类单例模式是日常开发中比较少用到的单例模式，原因是可读性较差</p>
<p><strong>优点：</strong>不仅可以解决多线程同步问题，还能有效防止反序列化重新创建新的对象</p>
<p><strong>缺点：</strong> jdk1.5中加入了enum，不常用，并且可读性差</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>目前来说，比较推荐的是静态内部类单例模式</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群架构</title>
    <url>/2021/04/09/redis%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>a先说说是为什么引入的redis集群，在我开发的一个项目中，涉及到了缓存雪崩的问题，当时想到的解决方案是，写一个随机数，随机redis的失效时间，但是，在后续发现了一个问题。</p>
<p><strong>例如：</strong>在早上七点我redis随机了三个小时失效，早上八点我又随机了两个小时失效，这种情况下，在早上十点还是会引发雪崩的问题，并且我们无法保证redis宕机后会怎么办，所以引出了今天redis集群的思考，接下来我们先学习一下reids集群的三种模式。</p>
<span id="more"></span>

<h2 id="1-主从模式"><a href="#1-主从模式" class="headerlink" title="1.主从模式"></a>1.主从模式</h2><p>我们先说一下主从模式的模型，一台主redis，其他子redis全部链接主redis，如下图所示</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png?Expires=1617978251&OSSAccessKeyId=TMP.3KjuXqBNoxYUJsUN2DMecUGsMv17fXxuEez93MK7Y9YojdR3ot12T887moFvZ8kbEwAFArs7xYPBWtdP5koLG6znEkXSow&Signature=hTkuCfyguf0aBlOvY0e8CA5hIJU=" alt="文件无法预览。"></p>
<p><strong>器中主从模式有如下特点：</strong></p>
<ol>
<li><p>主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库</p>
</li>
<li><p>从数据库一般都是只读的，并且接收主数据库同步过来的数据</p>
</li>
<li><p>一个master可以拥有多个slave，但是一个slave只能对应一个master</p>
</li>
<li><p>slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来</p>
</li>
<li><p>master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务</p>
</li>
<li><p>master挂了以后，不会在slave节点中重新选一个master</p>
</li>
</ol>
<p>  <strong>工作机制</strong></p>
<p>  当slave启动后主动向master发送SYNC命令，master接收到SYNC命令后，在后台保存快照(RDB持久化)和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令(这里的redis持久化可看redis持久化那篇文章)。<br>  复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。<br>  当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制<br>  主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。</p>
<p>  <strong>优点:</strong>  只从master中进行写操作，读操作全都从slave中进行操作，减轻了服务器的压力</p>
<p>  <strong>缺点:</strong>  当master端坏掉后，则无法进行写操作</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>  如果多个slave同时断线需要重启的时候，因为只要slave启动，就会和master建立连接发送SYNC请求和主机全量同步，如果多个同时发送SYNC请求，可能导致master IO突增而发送宕机。</p>
<h2 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2.哨兵模式"></a>2.哨兵模式</h2><p>主从模式的弊端就是不具备高可用性，当master挂掉以后，redis无法对外提供写入操作，所以产生了哨兵模式。哨兵模式就是，监控redis集群的运行情况</p>
<p><strong>哨兵模式的特点：</strong></p>
<ul>
<li>sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义</li>
<li>当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master</li>
<li>当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据</li>
<li>sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群</li>
<li>多sentinel配置的时候，sentinel之间也会自动监控</li>
<li>当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心</li>
<li>一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis</li>
<li>sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了</li>
</ul>
<p><strong>哨兵模式工作机制：</strong></p>
<ul>
<li>每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 </li>
<li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 </li>
<li>如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态</li>
<li>当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 </li>
<li>在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 </li>
<li>当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 </li>
<li>若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；<br>若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除</li>
</ul>
<p>当我们在使用哨兵模式时，客户端不要直接链接redis，直接链接sentinel的ip和端口就可以，因为哨兵模式中，我们使用sentinel来提供具体可提供服务的redis，这样，当master节点挂掉后，sentinel就会感知并将新的master节点提供给我们，从而避免我们不知道应该连接哪个节点的问题。</p>
<p>(哨兵模式的配置问题不在本章中作为讲解)</p>
<h2 id="3-集群模式"><a href="#3-集群模式" class="headerlink" title="3.集群模式"></a>3.集群模式</h2><p>哨兵模式可以基本满足我们平时开发的需求，并具备高可用性，但是当数据量过大到一台服务器放不下的情况，主从模式和哨兵模式就无法满足需求了，这时有一个解决方案是将数据分片存储，将数据分别存储到多个redis实例中，集群模式是专门为了解决单机存储上限的问题，将redis的数据根据一定的规则分配到多台服务器中。</p>
<p>集群模式可以说是哨兵模式和主从模式的融合，通过集群模式可以实现主从那个和master重选功能，所以如果配置两个副本三个分片的话，就要配置六个redis服务。因为redis的数据是根据一定鬼册分配到集群的不同机器中，当数据量过大时，可以增加机器进行扩容，使用集群，是需要将redis配置文件中的’cluster-enable’配置打开即可，每个集群中至少需要三个主数据库才能正常运行，新增节点方便。</p>
<p><strong>集群模式特点:</strong></p>
<ul>
<li>多个redis节点网络互联，数据共享 </li>
<li>所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用 </li>
<li>不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上， 并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为 </li>
<li>支持在线增加、删除节点 </li>
<li>客户端可以连接任何一个主节点进行读写</li>
</ul>
<p>这里需要主义的一点是，如果redis版本较低，则需要安装ruby，人选一台机器安装ruby即可，redis5.0以上版本可以直接创建集群。</p>
<p>redis集群是去中心化的，每个节点都是平等的，链接哪个节点都是可以获取和设置数据。平等只得是master节点，因为slave节点根本不提供服务，只是作为对应master节点的一个备份</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是集群的介绍，但是集群能解决的只是数据的可用性，和稳定性，我们最开始的起点还是无法解决，在下面我们继续对以上的问题进行解决分析，我们解决了数据库宕机引发的问题，接下来我们还需要继续解决缓存雪崩的问题。</p>
<p>后来想到一个解决方案，redis的失效时间是一定要设置的，但是我们可以设置一个逻辑失效时间，在value中，我们定义一个时间，当拉取数据时，我们会解析一下，value中的逻辑失效时间是否过期，如果逻辑过期，那我们会单独开一条线程刷新redis失效时间和逻辑失效时间，主线程继续走逻辑，这样可以避免数据的雪崩问题，但是如此解决还是无法根治大量数据失效大量请求打到mysql中，所以我们可以设置一个最终方案，在最后加入rabbitmq，当数据请求到mysql中后，会进入队列，但是走队列的话，会有一个问题，就是数拒响应会延长时间，但是目前来看这是最稳妥的解决方案，如果有更好的解决方案，欢迎私信讨论。</p>
<p>最终，我想到缓存雪崩的解决方案是，redis哨兵+逻辑失效时间+mq</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2021/04/18/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>今天学习一下数据结构，经常看到单链表的文章，面试也经常会问，那么接下来，我们开始进入单链表的学习。</p>
<p>首先，单链表的数据结构是什么样的呢？单链表的代码是如何实现的呢？我们先看一下单链表的数据结构图。</p>
<p><img src="https://img-blog.csdn.net/20160420141138723" alt="单链表数据结构图"></p>
<p>单链表由点点组成，一个链表拥有不定数量的节点，在内存中存储是不连续的，它存储的数据分散在内存中，如上图所示，每个节点由两部分组成，自己的对象和下一个节点的引用，每个节点也只能知道下一个节点的存储位置。由N个节点(Node)组成单链表，每个Node记录本Node的数据以及下一个Node,对外暴露的只有一个头节点(Head),我们对链表的所有操作，都是直接或者间接的通过头节点进行的。</p>
<p>上图的结构中，最左面的就是头节点(Head) ， 但是添加节点的作用是从右向左的，添加新节点会呗作为新节点。最先添加的节点对下一个节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象，因为有着不断的引用，所以头节点就可以操作所有节点，下图描述了单项链表存储情况，存储时分散的，每个节点只要记录下一节点，就把所有数据串了起来，形成一个单项链表。</p>
<p><img src="https://img-blog.csdn.net/20160420134010570" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2021/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>整个操作看成为一个整体，要么成功，要么失败，有一个回滚机制</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>这里涉及到了数据库锁<br>排他锁<br>X锁，写锁<br>共享锁<br>S锁，读锁<br>可能会有多个线程同时访问同一条数据，这样数据库会出现一条数据多方调用，这么做会产生数据的更新丢失，<br>为了压制数据更新丢失，数据库标准提出了四类隔离级别</p>
<span id="more"></span>

<h5 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h5><p>未提交读是最低的隔离级别，他允许一个事务读取另一个事务未提交的数据，未提交读是一种非常危险的隔离级别<br><strong>优点</strong><br>并发能力高，适用对数据一致性没有高要求的并发场景<br><strong>缺点</strong><br>会产生脏读<br>脏读的场景为在一条事务未提交时，令一条事务访问了当前事务的数据，但是当前事务数据回滚了，这时，读取到的事务就成为脏读</p>
<h5 id="读写提交"><a href="#读写提交" class="headerlink" title="读写提交"></a>读写提交</h5><p>在事务A进行的时候，事务B不会读取到事务A的任何数据<br><strong>优点</strong><br>读取事务不需要担心其他事务回滚而产生的脏读数据<br><strong>缺点</strong></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>当数据库数据只剩一个的情况下，事务A先扣除库存，这时事务B也进行扣除库存，因为无法读取事务A的操作，所以事务B判断可以扣除库存，这时事务A提交了数据,之后事务B提交数据就会提交失败，因为此时库存为0无法扣除<br>一般发生在delete和update中</p>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>在一个事务进行操作的时候，其他事务不允许读取当前数据库，要等待当前事务提交后才能进行读取，但是在一个事务中多次查询的结果是一致的<br><strong>优点</strong><br>可以完美的避开不可重复读的问题<br><strong>缺点</strong><br>幻读<br>发生在insert中<br>当事务A中有两条select语句，当执行完第一条select语句口，事务B对数据库进行了操作，添加了一条数据，这时事务A第二条select查看就会发现多了一条之前没有查到的数据<br>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。<br>解决方案，innodb数据库引擎已经解决当前问题<br>Innodb引入间隙锁</p>
<h5 id="串行话"><a href="#串行话" class="headerlink" title="串行话"></a>串行话</h5><p>这个是数据库的最高隔离级别，当一个事务执行时，其他事务都要排队，按顺序一个一个的进行<br>缺点<br>会产生数据的冗余</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>当整个事务执行完毕后，所有数据都会被固化到磁盘中，供长期的访问</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务在完成时，必须使所有事务都保持一致</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/03/10/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存（缓存雪崩，缓存击穿，缓存穿透）"><a href="#缓存（缓存雪崩，缓存击穿，缓存穿透）" class="headerlink" title="缓存（缓存雪崩，缓存击穿，缓存穿透）"></a>缓存（缓存雪崩，缓存击穿，缓存穿透）</h1><p><strong>首先</strong>，什么是缓存，在计算机中，数据的运行方式是 CPU&gt;内存&gt;储存，所以内存是直接与cpu交流的，最接近CPU的，所以内存的效率是很高的，但是，内存是RAM，也就是说，当机器停机或断电情况下，内存会全部消失。</p>
<span id="more"></span>

<p>在日常开发中我们使用的缓存一般是指redis缓存数据库，redis的细节在此不做讲解，后续会出一篇redis的文章，在此篇文章中主要介绍缓存雪崩，缓存击穿，缓存穿透这三个问题。</p>
<p> 我们为什么要在项目中添加缓存，直接用数据库查询不好么？一条sql直接搞定，这是我在刚接触到缓存的时候想的问题，为什么呢，首先，缓存有两个主要的用途：<strong>高性能，高并发</strong>，现在是一个高并发的时代，会有很多人同时操作我们的项目，这时，数据库能承受多少的访问量呢？一条sql的select查询需要多久呢？每次我们操作都需要去数据库查询一遍相同的数据是不是重复操作呢？这些重复操作会浪费掉我们多少的性能呢？当有人恶意访问把我们的数据库查崩了会怎么样呢？等等好多的问题，都指向了缓存。</p>
<p>首先，redis数据库是非关系型数据库，一个key一个value，当我们在项目中加入缓存后，第一个人查询完，第二个人直接去缓存中拿这个数据，不需要再走一遍sql，最简单的例子，一条sql查询某个数据需要300ms，而你将这些数据放入到redis中，下次通过这个key进行查询的时候只需要3ms就可以查询出来。在高并发的情况下，mysql天然支持不是很好，当然也不是非说不可以，假如在我们的项目中，某个时间段，一秒钟有一万个请求，那么单个mysql的项目绝对会垮掉，这时候只要我们加上缓存，把大量的数据都放进缓存中，单个redis就可以轻松支撑每秒几万到几十万的数据，他的承载并发量是mysql的几十倍。</p>
<p>接下来步入正题，使用缓存后我们会遇到的第一个问题，缓存雪崩，缓存击穿，缓存穿透，这三种最常见的地方就是在电商项目中。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><strong>场景</strong><br>同一时间下有大量的数据同时失效，这时会对数据库产生庞大的压力<br>双十一十二点，大量用户访问商品，加入商品有效时间为一小时，一点后，所有缓存全部到期，这时就会触发缓存雪崩</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>高可用：</strong> redis主从复制和redis集群，redis 集群有哨兵和Cluster等，此处不做详细讲解</p>
<p><strong>限流降级：</strong> 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>随机过期时间：</strong> 将缓存的有效时间设置为随机数，每个缓存的失效时间都不相同，这样就可以有效的解决缓存雪崩</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>场景</strong><br>在大数据量的访问时，缓存失效了，这时会有大量请求直接击穿数据库，这就是缓存击穿<br>在淘宝中，一个商品卖成了热卖商品，在热卖的过程中，缓存失效了，这时一瞬间就会触发缓存雪崩问题</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>添加互斥锁</p>
<p>将热卖商品的缓存过期时间设置为永不过期</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>场景</strong><br>当有人知道当前请求的路径后，多次请求并不存在的数据，这样就会使请求直接穿透到数据库上，导致数据库压力过大<br>一个人恶意请求数据，疯狂发送不存在的数据，这时会产生缓存穿透</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>创建黑名单，将数据库不存在的数据存入到缓存黑名单中，每次访问，如果传参在黑名单中，则将黑名单中信息直接返回给请求者，这样可以避免数据走数据库</p>
<p>本人也在学习阶段，如有哪里写的有问题欢迎指点，不喜勿喷</p>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>装箱拆箱</title>
    <url>/2021/03/10/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="装箱-java中将这个机制设置为自动"><a href="#装箱-java中将这个机制设置为自动" class="headerlink" title="装箱(java中将这个机制设置为自动)"></a>装箱(java中将这个机制设置为自动)</h2><ul>
<li>装箱的概念为将基本数据类型转换为包装类型</li>
<li>构造函数：可用于将基本类型转换为包装器类型</li>
<li>valueOf()：可用于将基本类型转换为包装器类型</li>
<li>自动装箱<ul>
<li><p>int x= 1; Integer y = x;</p>
</li>
<li><p>public void demo(Integer a){} int x = 1; demo(x);</p>
<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="拆箱-java中将这个机制设置为自动"><a href="#拆箱-java中将这个机制设置为自动" class="headerlink" title="拆箱(java中将这个机制设置为自动)"></a>拆箱(java中将这个机制设置为自动)</h2><ul>
<li>拆箱的概念为将包装器类型转换成基本数据类型</li>
<li>byteValue()、shortValue()等xxxValue()方法：可用于将包装器类型转换为基本数据类型</li>
<li>parseInt()等parseXxx()方法：可用于将String对象转换为基本数据类型</li>
<li>toString()方法：由Object对象继承而来，用于将包装器类型转换为String类型</li>
<li>自动拆箱<ul>
<li>Integer x = new Integer(1); int y = x ;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池之Druid--配置篇</title>
    <url>/2021/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B9%8BDruid/</url>
    <content><![CDATA[<p>日常开发中数据库是我们都要使用的，使用数据库也就意味着必须建立项目和数据之间的联系，所以我们需要使用数据库连接池，目前我选择使用druid连接池，该连接池是阿里开源的，功能非常强大，最大的特点是可以监控sql和可视化界面，目前各种数据库连接池的特点如下图所示</p>
<p><img src="https://aaaas.oss-cn-beijing.aliyuncs.com/image-20210330202641268.png" alt="image-20210330202641268"></p>
<p><strong>步入正题</strong></p>
<span id="more"></span>

<p>druid有两种配置方式，阿里开源框架中为了springboot提供了封装好的引用包和druid原生的包，分别为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此依赖为druid原生的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 此依赖为springboot--druid的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-引用springboot-druid的配置"><a href="#1-引用springboot-druid的配置" class="headerlink" title="1. 引用springboot-druid的配置"></a>1. 引用springboot-druid的配置</h2><p>引用springboot-druid包后，当前包中已经为我们配置好了配置文件的映射方法，所以我们只需要在配置文件中添加配置就好，配置文件如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#以下为druid增加的配置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化时建立物理连接的个数</span><br><span class="line">spring.datasource.druid.initial-size=50</span><br><span class="line"># 最小连接池数量</span><br><span class="line">spring.datasource.druid.min-idle=50</span><br><span class="line"># 最大连接池数量</span><br><span class="line">spring.datasource.druid.max-active=10</span><br><span class="line"># 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁</span><br><span class="line">spring.datasource.druid.max-wait=60000</span><br><span class="line"># 有两个含义：</span><br><span class="line">#1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。</span><br><span class="line">#2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</span><br><span class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</span><br><span class="line"># 连接保持空闲而不被驱逐的最小时间</span><br><span class="line">spring.datasource.druid.min-evictable-idle-time-millis=30000</span><br><span class="line"># 用来检测连接是否有效的SQL,如果未null,testOnBorrow,testOnReturn,testWhileIdle不会起作用</span><br><span class="line">spring.datasource.druid.validation-query=SELECT 1</span><br><span class="line"># 检测链接是否有效的超时时间,单位秒;底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</span><br><span class="line">spring.datasource.druid.validation-query-timeout=10</span><br><span class="line"># 建议配置为true,不影响性能,并且保证安全性.申请连接的时候检测,如果空闲时间大于timeBetweenEvictionRunsMills,执行validationQuery检测连接是否有效.</span><br><span class="line">spring.datasource.druid.test-while-idle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-borrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效,做了这配置会降低性能</span><br><span class="line">spring.datasource.druid.test-on-return=false</span><br><span class="line"># 是否缓存preparedStatement,即PSCache,PSCache对支持游标的数据库性能提升巨大,如oracle,mysql下建议关闭</span><br><span class="line">spring.datasource.druid.pool-prepared-statements=false</span><br><span class="line"># 要启用PSCache,必须配置大于0,当大于0时,上面配置自动修改为true;Druid中不会存在Oracle下PSCache占用内存过多的问题,可以把数值配置大一些,如100</span><br><span class="line">spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20</span><br><span class="line">spring.datasource.druid.filter.stat.enabled=true</span><br><span class="line">spring.datasource.druid.filter.stat.merge-sql=true</span><br><span class="line">spring.datasource.druid.filter.stat.slow-sql-millis=5000</span><br><span class="line">#WebStatFilter监控配置</span><br><span class="line"># 这个教程很保姆,参考https://blog.csdn.net/qq_45173404/article/details/109075810</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=100</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line">#页面登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class="line">#页面登录用户密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br></pre></td></tr></table></figure>

<h2 id="2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"><a href="#2-在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式" class="headerlink" title="2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式"></a>2. 在我们引用原生的druid的情况下，我们需要手写druid的配置类，配置读取配置文件的格式</h2><p> 配置类如下所述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  主要实现WEB监控的配置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在要进行druid监控的配置处理操作</span></span><br><span class="line">        ServletRegistrationBean servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">                <span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 白名单,多个用逗号分割， 如果allow没有配置或者为空，则允许所有访问</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;127.0.0.1,172.29.32.54&quot;</span>);</span><br><span class="line">        <span class="comment">// 黑名单,多个用逗号分割 (共同存在时，deny优先于allow)</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;deny&quot;</span>, <span class="string">&quot;192.168.1.110&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理用户名</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理密码</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;eju1314&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否可以重置数据源，禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean() ;</span><br><span class="line">    filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">    <span class="comment">//所有请求进行监控处理</span></span><br><span class="line">    filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>); </span><br><span class="line">    <span class="comment">//添加不需要忽略的格式信息</span></span><br><span class="line">    filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.css,/druid/*&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> filterRegistrationBean ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完配置类后，我们的配置文件中配置如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.name=dev</span><br><span class="line"># 基本属性</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line"># 可以不配置，根据url自动识别，建议配置</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#=================================以下为druid增加的配置==========================</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 初始化连接池个数</span><br><span class="line">spring.datasource.initialSize=5</span><br><span class="line"># 最小连接池个数——》已经不再使用，配置了也没效果</span><br><span class="line">spring.datasource.minIdle=2</span><br><span class="line"> # 最大连接池个数</span><br><span class="line">spring.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间，单位毫秒，缺省启用公平锁，并发效率会有所下降</span><br><span class="line">spring.datasource.maxWait=60000</span><br><span class="line"> # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">spring.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">spring.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line"># 用来检测连接是否有效的sql，要求是一个查询语句。</span><br><span class="line">spring.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line"># 建议配置为true，不影响性能，并且保证安全性。</span><br><span class="line"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span><br><span class="line">spring.datasource.testWhileIdle=true</span><br><span class="line"># 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnBorrow=false</span><br><span class="line"># 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span><br><span class="line">spring.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">spring.datasource.poolPreparedStatements=true</span><br><span class="line">spring.datasource.maxPoolPreparedStatementPerConnectionSize=20</span><br><span class="line"># 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有： </span><br><span class="line"># 监控统计用的filter:stat</span><br><span class="line"># 日志用的filter:log4j</span><br><span class="line"># 防御sql注入的filter:wall</span><br><span class="line">spring.datasource.filters=stat,wall,log4j</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">spring.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql回表</title>
    <url>/2022/04/12/mysql%E5%9B%9E%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Mysql回表"><a href="#Mysql回表" class="headerlink" title="Mysql回表"></a>Mysql回表</h1><h2 id="首先我们要先了解什么是聚簇索引和非聚簇索引"><a href="#首先我们要先了解什么是聚簇索引和非聚簇索引" class="headerlink" title="首先我们要先了解什么是聚簇索引和非聚簇索引"></a>首先我们要先了解什么是聚簇索引和非聚簇索引</h2><p>在本文中，我们使用的都是mysql的Innodb存储引擎</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ul>
<li>如果表设置了主键，则主键就是聚簇索引</li>
<li>如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引</li>
<li>以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引<blockquote>
<p>InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。<br>由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录</p>
</blockquote>
</li>
</ul>
<p><strong>总结：</strong> 找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。</p>
<span id="more"></span>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><ul>
<li>就是普通索引</li>
<li>索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。</li>
</ul>
<h5 id="如下是普通索引的结构"><a href="#如下是普通索引的结构" class="headerlink" title="如下是普通索引的结构"></a>如下是普通索引的结构</h5><ul>
<li>其子节点上存储了聚簇索引的值<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/10/1702e72ac4e50ce0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"><h5 id="如下是聚簇索引的结构"><a href="#如下是聚簇索引的结构" class="headerlink" title="如下是聚簇索引的结构"></a>如下是聚簇索引的结构</h5></li>
<li>其子结点上存储的是对应数据<blockquote>
<p>如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。<br>如：select * from user where id = 1;<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/10/1702e72ac12c1c70~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：select * from user where age = 30;</p>
</blockquote>
<p><strong>流程为：</strong> </p>
<ol>
<li>先通过普通索引 age=30 定位到主键值 id=1</li>
<li>再通过聚集索引 id=1 定位到行记录数据</li>
</ol>
<p><strong>普通查询第一步</strong><br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/10/1702e72abff3fce7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
<p><strong>普通查询第二步</strong><br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/10/1702e72ac17d1967~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
<h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><p>我们通过普通索引查询的时候就触发了回表查询像上图所画的那样</p>
<blockquote>
<p>先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>索引覆盖</strong></p>
<blockquote>
<p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。<br>例如：select id,age from user where age = 10;</p>
</blockquote>
<p><strong>如何实现覆盖索引</strong></p>
<blockquote>
<p>常见的方法是：将被查询的字段，建立到联合索引里去。</p>
<p>1、如实现：select id,age from user where age = 10;<br>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引</p>
</blockquote>
<blockquote>
<p>2、实现：select id,age,name from user where age = 10;<br>explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询</p>
</blockquote>
<p>为了实现索引覆盖，需要建组合索引idx_age_name(age,name)</p>
<p><code>drop index idx_age on user;</code><br><code>create index idx_age_name on user(</code>age<code>,</code>name<code>);</code></p>
<blockquote>
<p>explain分析：此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖，此时的Extra字段为Using index表示使用了索引覆盖。</p>
</blockquote>
]]></content>
      <categories>
        <category>日常学习</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
