---
title: redis集群架构
date: 2021-04-09 21:52:44
tags: redis
categories: 日常学习
---

a先说说是为什么引入的redis集群，在我开发的一个项目中，涉及到了缓存雪崩的问题，当时想到的解决方案是，写一个随机数，随机redis的失效时间，但是，在后续发现了一个问题。

**例如：**在早上七点我redis随机了三个小时失效，早上八点我又随机了两个小时失效，这种情况下，在早上十点还是会引发雪崩的问题，并且我们无法保证redis宕机后会怎么办，所以引出了今天redis集群的思考，接下来我们先学习一下reids集群的三种模式。

<!-- more -->

## 1.主从模式

我们先说一下主从模式的模型，一台主redis，其他子redis全部链接主redis，如下图所示

![文件无法预览。](https://aaaas.oss-cn-beijing.aliyuncs.com/1557639147418-27b8b69d-f0a8-4ec0-a771-99c43783190d.png?Expires=1617978251&OSSAccessKeyId=TMP.3KjuXqBNoxYUJsUN2DMecUGsMv17fXxuEez93MK7Y9YojdR3ot12T887moFvZ8kbEwAFArs7xYPBWtdP5koLG6znEkXSow&Signature=hTkuCfyguf0aBlOvY0e8CA5hIJU%3D)

**器中主从模式有如下特点：**

1. 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库

2. 从数据库一般都是只读的，并且接收主数据库同步过来的数据

3. 一个master可以拥有多个slave，但是一个slave只能对应一个master

4. slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来

5. master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务

6. master挂了以后，不会在slave节点中重新选一个master

  **工作机制**

  当slave启动后主动向master发送SYNC命令，master接收到SYNC命令后，在后台保存快照(RDB持久化)和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令(这里的redis持久化可看redis持久化那篇文章)。
  复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。
  当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制
  主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。

  **优点:**  只从master中进行写操作，读操作全都从slave中进行操作，减轻了服务器的压力

  **缺点:**  当master端坏掉后，则无法进行写操作

  #### 注意：

  如果多个slave同时断线需要重启的时候，因为只要slave启动，就会和master建立连接发送SYNC请求和主机全量同步，如果多个同时发送SYNC请求，可能导致master IO突增而发送宕机。

## 2.哨兵模式

主从模式的弊端就是不具备高可用性，当master挂掉以后，redis无法对外提供写入操作，所以产生了哨兵模式。哨兵模式就是，监控redis集群的运行情况

**哨兵模式的特点：**

* sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义
* 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master
* 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据
* sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群
* 多sentinel配置的时候，sentinel之间也会自动监控
* 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心
* 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis
* sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了

**哨兵模式工作机制：**

* 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 
* 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 
* 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态
* 当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 
* 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 
* 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 
* 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；
  若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除

当我们在使用哨兵模式时，客户端不要直接链接redis，直接链接sentinel的ip和端口就可以，因为哨兵模式中，我们使用sentinel来提供具体可提供服务的redis，这样，当master节点挂掉后，sentinel就会感知并将新的master节点提供给我们，从而避免我们不知道应该连接哪个节点的问题。

(哨兵模式的配置问题不在本章中作为讲解)

## 3.集群模式

哨兵模式可以基本满足我们平时开发的需求，并具备高可用性，但是当数据量过大到一台服务器放不下的情况，主从模式和哨兵模式就无法满足需求了，这时有一个解决方案是将数据分片存储，将数据分别存储到多个redis实例中，集群模式是专门为了解决单机存储上限的问题，将redis的数据根据一定的规则分配到多台服务器中。

集群模式可以说是哨兵模式和主从模式的融合，通过集群模式可以实现主从那个和master重选功能，所以如果配置两个副本三个分片的话，就要配置六个redis服务。因为redis的数据是根据一定鬼册分配到集群的不同机器中，当数据量过大时，可以增加机器进行扩容，使用集群，是需要将redis配置文件中的'cluster-enable'配置打开即可，每个集群中至少需要三个主数据库才能正常运行，新增节点方便。

**集群模式特点:**

* 多个redis节点网络互联，数据共享 
* 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用 
* 不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上， 并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为 
* 支持在线增加、删除节点 
* 客户端可以连接任何一个主节点进行读写

这里需要主义的一点是，如果redis版本较低，则需要安装ruby，人选一台机器安装ruby即可，redis5.0以上版本可以直接创建集群。

redis集群是去中心化的，每个节点都是平等的，链接哪个节点都是可以获取和设置数据。平等只得是master节点，因为slave节点根本不提供服务，只是作为对应master节点的一个备份

### 总结

以上是集群的介绍，但是集群能解决的只是数据的可用性，和稳定性，我们最开始的起点还是无法解决，在下面我们继续对以上的问题进行解决分析，我们解决了数据库宕机引发的问题，接下来我们还需要继续解决缓存雪崩的问题。

后来想到一个解决方案，redis的失效时间是一定要设置的，但是我们可以设置一个逻辑失效时间，在value中，我们定义一个时间，当拉取数据时，我们会解析一下，value中的逻辑失效时间是否过期，如果逻辑过期，那我们会单独开一条线程刷新redis失效时间和逻辑失效时间，主线程继续走逻辑，这样可以避免数据的雪崩问题，但是如此解决还是无法根治大量数据失效大量请求打到mysql中，所以我们可以设置一个最终方案，在最后加入rabbitmq，当数据请求到mysql中后，会进入队列，但是走队列的话，会有一个问题，就是数拒响应会延长时间，但是目前来看这是最稳妥的解决方案，如果有更好的解决方案，欢迎私信讨论。

最终，我想到缓存雪崩的解决方案是，redis哨兵+逻辑失效时间+mq

