---
title: 数据库事务
date: 2021-03-10 16:28:15
tags: 数据库
categories: 日常学习
---

## 四大特性

### 原子性

整个操作看成为一个整体，要么成功，要么失败，有一个回滚机制

### 隔离性

这里涉及到了数据库锁
排他锁
X锁，写锁
共享锁
S锁，读锁
可能会有多个线程同时访问同一条数据，这样数据库会出现一条数据多方调用，这么做会产生数据的更新丢失，
为了压制数据更新丢失，数据库标准提出了四类隔离级别

<!-- more -->

##### 未提交读

未提交读是最低的隔离级别，他允许一个事务读取另一个事务未提交的数据，未提交读是一种非常危险的隔离级别
**优点**
并发能力高，适用对数据一致性没有高要求的并发场景
**缺点**
会产生脏读
脏读的场景为在一条事务未提交时，令一条事务访问了当前事务的数据，但是当前事务数据回滚了，这时，读取到的事务就成为脏读

##### 读写提交

在事务A进行的时候，事务B不会读取到事务A的任何数据
**优点**
读取事务不需要担心其他事务回滚而产生的脏读数据
**缺点**

##### 不可重复读

当数据库数据只剩一个的情况下，事务A先扣除库存，这时事务B也进行扣除库存，因为无法读取事务A的操作，所以事务B判断可以扣除库存，这时事务A提交了数据,之后事务B提交数据就会提交失败，因为此时库存为0无法扣除
一般发生在delete和update中

##### 可重复读

在一个事务进行操作的时候，其他事务不允许读取当前数据库，要等待当前事务提交后才能进行读取，但是在一个事务中多次查询的结果是一致的
**优点**
可以完美的避开不可重复读的问题
**缺点**
幻读
发生在insert中
当事务A中有两条select语句，当执行完第一条select语句口，事务B对数据库进行了操作，添加了一条数据，这时事务A第二条select查看就会发现多了一条之前没有查到的数据
在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
解决方案，innodb数据库引擎已经解决当前问题
Innodb引入间隙锁

##### 串行话

这个是数据库的最高隔离级别，当一个事务执行时，其他事务都要排队，按顺序一个一个的进行
缺点
会产生数据的冗余

#### 持久性

当整个事务执行完毕后，所有数据都会被固化到磁盘中，供长期的访问

#### 一致性

事务在完成时，必须使所有事务都保持一致

