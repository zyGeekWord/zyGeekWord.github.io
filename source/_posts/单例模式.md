---
title: 单例模式
date: 2021-03-10 11:48:07
tags: 设计模式
categories: 编程思想
---

Java的设计模式一共有23中，今天我们说单例模式，单例模式是一种最常见的设计模式，在springmvc中bean的注入使用的就是单例模式。

单例模式，只能存在一个实例，并且自己创建自己的对象，这个类提供了一个访问这个对象的唯一方式，可直接访问，不需要通过new来创建一个新的对象，单例模式一共有五种创建方式，下面分别查看这几种方式。

<!-- more -->

**单例模式的优点：**

1. 内存中只有一个对象，节省内存空间。
2. 避免频繁的创建销毁对象，可以提高性能。
3. 避免对共享资源的多重占用，简化访问。
4. 为整个系统提供一个全局访问点。

**单例模式的缺点：**

1. 不适用于变化频繁的对象。
2. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现的链接池溢出。
3. 如果实例化的对象长时间不被利用，系统会认为该对象时垃圾而被回收，这可能会导致对象状态的丢失。



#### 1.懒汉式

```
public class LanHan{
    private static LanHan lan;
    //私有构造器
    private LanHan(){}
    //判断，当没有创建过对象的时候才会创建新对象
    public static LanHan getLan(){
        if(lan==null){
            lan = new LanHan;
        }
        return lan;
    }
}
```

懒汉式，只有在使用的时候才会创建

**优点：**节省内存空间，只有在真正调用的时候才会实例化对象并调用。

**缺点：**只能在单线程情况下使用，在多线程情况下，一个线程进行if else 判断的时候还没有进行运算完成，接下来的线城也进入判断，这样便会创建了多个实例，违背了单例模式的设计意义，并且，严格意义上来说，懒汉式并不属于单例模式

#### 2.饿汉式

```
public class EHan{
    //创建自己的私有静态对象
    private static EHan eh = new EHan();
    //私有构造器
    private EHan(){}
    //返回自己实例的静态公有方法
    public EHan getEH(){
        return en;
    }
}
```

饿汉式，在初始化时已经创建好，不管是否调用

**优点：**在整个生命周期只会被加载一次，只会创建一个实例，这种写法很简单，避免了线程同步的问题

**缺点：**在类装载的时候就完成实例化，如果始终没有调用的话，会浪费内存

#### 3.双重加锁机制

```java

public class Singleton {
    private volatile static Singleton uniqueSingleton;
 
    private Singleton() {
    }
 
    public Singleton getInstance() {
        if (null == uniqueSingleton) {
            synchronized (Singleton.class) {
                if (null == uniqueSingleton) {
                    uniqueSingleton = new Singleton();
                }
            }
        }
        return uniqueSingleton;
    }
}
```

**知识点：**lock锁

Double-Check概念，进行了两次if检测，这样可以保证线程安全，这样实例化代码只用执行一次，后面再次访问时，判断singleton==null直接返回实例化对象

使用双重检测同步延迟加载去创建单例模式是一种非常优秀的做法，不但保持了单例，还切实提高了程序运行效率

**优点：**线城安全，延迟加载，效率高

这里涉及到了一个关键字volatile，请看后续专门讲解的文章

#### 4.静态初始化

```
public class staticleton { 
    private staticleton(){
    }
      public static staticleton getInstance(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
}
```

只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。

**优点：**利用了classloader机制来保证初始化instance时只有一个线程，线程安全且没有性能损耗

#### 5.枚举单例模式

```
public enum Singleton  {
    INSTANCE 
 
    //doSomething 该实例支持的行为
      
    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton get Instance() {
        return Singleton.INSTANCE;
    }
}
```

枚举类单例模式是日常开发中比较少用到的单例模式，原因是可读性较差

**优点：**不仅可以解决多线程同步问题，还能有效防止反序列化重新创建新的对象

**缺点：** jdk1.5中加入了enum，不常用，并且可读性差

## 总结：

目前来说，比较推荐的是静态内部类单例模式

