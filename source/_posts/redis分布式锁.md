---
title: redis分布式锁
date: 2021-04-11 20:01:48
tags: redis
categories: 日常学习
---

#### 首先redis锁要解决什么？(内含本人使用思考)

* 互斥性：任意时刻只能有一个客户端获取锁，不能同时有两个客户端获取到锁；
* 安全性：锁只能被持有的客户端删除，不能由其他客户端删除；
* 死锁：获取锁的客户端因为某些原因而宕机而未能释放锁，其他客户端再也无法获取到该锁导致的死锁，此时需要有机制来避免问题的发生；
* 容错：当部分节点如redis某些节点宕机时，客户端仍然能够获取锁和释放锁

<!-- more -->

#### SETNX key value

如果key不存在，则创建并赋值（set if not exist）
时间复杂度：O(1)
返回值：设置成功，返回1；设置失败，返回0

setnx是原子性的，初期时候被人们用来实现分布式锁。在执行某段代码时候可以先尝试使用setnx，为某个key设值。如果设置成功，则证明此时没有别的线程在执行该段代码，或者说占用该独占资源，这个时候我们线程就可以顺利地去执行该段代码逻辑，如果设置失败，则证明此时有别的程序或者线程占用该资源。那么当前线程就需要等待，直至setnx成功。

#### EXPIRE key seconds

为给定key设置生存时间，当key过期时（生存时间为0），会被自动删除
缺点：原子性得不到满足
假设setnx执行成功后就直接宕机，来不及expire，此时key就会被一直占用着，意味着其他线程永远也执行不了独占的资源逻辑了，这样就违背了利用redis操作的原子性。

#### SET key value [EX seconds] [PX milliseconds] [NX|XX]

EX second：设置键的过期时间为second秒
PX millisecond：设置键的过期时间为millisecond毫秒
NX：只在键不存在时，才对键进行设置操作
XX：只在键已经存在时，才对键进行设置操作
SET操作成功完成时，返回OK，否则返回(nil)

#### 大量的key同时过期的注意事项：

如果大量的key过期时间设置的过于集中，到过期的时间点，由于删除key是需要时间的，redis可能会因为一次性大量删除key出现短暂卡顿现象，面对这种情况解决方法为：在设置key的过期时间上加一个随机值，使过期时间分散一些，这样可在很大程度上避免卡顿的发生。



##### 本人项目中应用事件

需求如下，项目中，有一个api是生成一个excel表格，每个user只能生成一次excel，但是，当有两个人，用同一个user请求api时，会生成两次excel，此时我的解决方案是，使用redis，通过将key设置为userId，每次请求前，先查看redis中是否有此key，如果有，则返回生成中，如果没有，则SET一个key设置失效时间并向下进行，待完成后，DELETE此key。但是此方法有一个致命的问题，当进程a先锁住后，生成过程中遇到了问题，进程卡住，当失效时间达到后，锁失效，进程B就会开始执行，当进程B执行一半后，进程A执行完毕，数据生成成功，将状态修改为已生成，此时因为redis中还有跟他一样的key，所以删除锁，这时，进程B运行完成，但却发现状态已经被修改，此时会触发报错。

想到的解决方案是，在vaue中存一个uuid，每次生成key之前生成一个uuid，存入value中，当运行结束后，先判断redis中是否有当前的key，如果有的话，则对比value中uuid是否为自己的uuid，如果不是，则本次逻辑作废，返回生成失败，反之成功。

